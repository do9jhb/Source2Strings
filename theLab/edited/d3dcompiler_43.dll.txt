!This program cannot be run in DOS mode.
@.reloc
Fd3d10.dll
d3d10_1.dll

__fx_2_0__
Shader@0x%p
D3DCompile: Invalid flags specified
#pragma pack_matrix(row_major)
#pragma pack_matrix(column_major)
#pragma pack_matrix()
#pragma ruledisable 0x%08x
#line %u %.*s
#line %u
#pragma def (%s, %s, %g, %g, %g, %g)
#pragma warning (once:%d)
#pragma warning (disable:%d)
#pragma warning (error:%d)
D3DCompressedData
break_c
texdepth
texm3x3
texm3x2depth
texdp3tex
texreg2rgb
texm3x3vspec
texm3x3spec
texm3x3tex
texm3x3pad
texm3x2tex
texm3x2pad
texreg2gb
texreg2ar
texbeml
texkill
texcoord
endloop
boolean constant register '%s' must be defined as a variable of type bool only
integer constant register '%s' must be defined as a variable of type int3 or int4 only
Constant variable '%s' bound to register greater than 8191 (%d requested)
Sampler variable '%s' does not specify the sampler type.  Explicit sampler types required for asm fragments.
POSITION
BLENDWEIGHT
BLENDINDICES
TEXCOORD
TANGENT
BINORMAL
TESSFACTOR
POSITIONT
DIFFUSE
SPECULAR
invalid register, input, or constant name '%s'
Invalid input register '%s' specified
addressing operations are not allowed on input registers '%s'
Invalid pixel shader input register '%s' specified
addressing operations not allowed on temporary registers '%s'
constant register '%s' must be defined as a variable '%s'
constant register address out of bounds on constant '%s', size %d, offset %d
Invalid output register '%s' specified
addressing operations are not allowed on output registers '%s'
'%s' is not a valid register name.  Registers must start with v_, r_, c_, b_, or i_ depending on the register type. (o_ for vs_3_0 only)
shader version expected
vs_1_0 is no longer supported; using vs_1_1
ps_1_0 is no longer supported; using ps_1_1
unrecognized shader version
only vs_1_1, vs_2_0, vs_2_x, vs_2_sw, ps_2_0, ps_2_x, and ps_2_sw are supported for assembly fragments
d3d9.dll
Direct3DShaderValidatorCreate9
entrypoint
internal error: stack underflow
instruction coissue is not supported in this shader version
instruction predication is not supported in this shader version
scalar registers cannot be masked
not cannot be used with other modifiers
negate and divide modifiers cannot be combined
invalid complement expression
complement is not supported in this shader version
complement cannot be used with other modifiers
scalar registers cannot be swizzled
only one address register reference allowed in a relative address expression
internal error: out of memory
syntax error
'%s' is not a valid instruction in this shader version
invalid instruction modifiers '%s'
internal error: production failed
centroid
position
blendweight
blendindices
tangent
binormal
tessfactor
positiont
temporary, constant, and output registers are not allowed in vs_3_0 assembly fragments
temporary and constant registers are not allowed in assembly fragments
invalid register '%s[%u]'
invalid register '%s[...]'
invalid register '%s'
invalid mask '%s'
invalid swizzle '%s'
call, callnz, label, and ret instructions are not allowed in assembly fragments
Matrices cannot be specified in temp registers with the fragment linker
source modifiers are not allowed on destination parameters
relative addressing of destination parameters is not supported in this shader version
only one address register reference is allowed in a relative address expression
predicates are not supported in this shader version
source modifiers are not allowed on predicates
relative addressing of predicates is not supported in this shader version
source modifiers incompatible with SUB instruction
only a0.x is allowed as a relative address register in vs_1_1
internal error: instruction size mismatch
Microsoft (R) D3DX9 Shader Assembler 9.29.952.3111
fragment info exceeds maximum comment size
debug info exceeds maximum comment size; no debug info emitted
memory exhausted
forceEarlyDepthStencil
enableRawAndStructuredBuffers
enableDoublePrecisionFloatOps
refactoringAllowed
Texture
Texture1D
Texture1DArray
Texture2D
Texture2DMS
Texture2DArray
Texture2DMSArray
Texture3D
TextureCube
TextureCubeArray
sampler
SamplerState
sampler1D
sampler2D
sampler3D
samplerCUBE
PixelShader
VertexShader
GeometryShader
HullShader
DomainShader
RasterizerState
DepthStencilState
BlendState
RenderTargetView
DepthStencilView
pixelfragment
vertexfragment
interface
ComputeShader
UNKNOWN
row_major %s%ux%u
%s%ux%u
struct %s
// Offset: %4u
<continued>
<unknown resource return type>
<unused>
// Buffer Definitions: 
cbuffer
tbuffer
interfaces
Resource bind info for
<unknown buffer type>
// %s %s
// Offset:  N/A Size:   N/A [unused]
 [unused]
// Offset: %4u Size: %5u%s
0x%08x 
Textures:  t%u-t%u
Texture:   t%u
Samplers: s%u-s%u
Sampler: s%u
// Resource Bindings:
// Name                                 Type  Format         Dim Slot Elements
// ------------------------------ ---------- ------- ----------- ---- --------
texture
sampler_c
cubearray
1darray
2darray
r/w+cnt
consume
// %-30s %10s %6s%d %11s %4u %8u
// %-30s %10s %7s %11s %4u %8u
// Constant buffer to DX9 shader constant mappings:
// Target Reg Buffer  Source Reg Component
// ---------- ------- ---------- ---------
// b%-9d cb%-5d %10d %9d
// i%-9d cb%-5d %10d %9d
// Target Reg Buffer  Start Reg # of Regs        Data Conversion
// ---------- ------- --------- --------- ----------------------
// clip%-6d cb%-5d %9d %9d  (
// c%-9d cb%-5d %9d %9d  (
// Runtime generated constant mappings:
// Target Reg                               Constant Description
// ---------- --------------------------------------------------
Vertex Shader position offset
Instance ID
Unknown Value
// c%-10d %49s
// Sampler/Resource to DX9 shader sampler mappings:
// Target Sampler Source Sampler  Source Resource
// -------------- --------------- ----------------
// s%-13d s%-14d t%-16d
// Approximately %i instruction slots used
<internal error>
Undefined
Isoline
Triangle
Quadrilateral
// Tessellation Domain   # of control points
// -------------------- --------------------
// %-20s %20u
Clockwise Triangles
Counter-Clockwise Triangles
Integer
Integer Power of 2
Odd Fractional
Even Fractional
// Tessellation Output Primitive  Partitioning Type 
// ------------------------------ ------------------
// %-30s %-18s
// %s signature:
// Name                 Index   Mask Register SysValue Format   Used
// -------------------- ----- ------ -------- -------- ------ ------
// no %s
SV_Depth
    N/A
   oDepth
SV_DepthGreaterEqual
 oDepthGE
SV_DepthLessEqual
 oDepthLE
SV_Coverage
    oMask
   primID
  special
   %c%c%c%c
CLIPDST
CULLDST
RTINDEX
VPINDEX
DEPTHGE
DEPTHLE
COVERAGE
QUADEDGE
QUADINT
TRIEDGE
LINEDET
LINEDEN
unknown
    YES
     NO
[%s%d[%s].%c]
[%s%d.%c]
 vPSize
// approximately %u instruction%s used
Error: Texture shader assembly not found!
Error: Error getting texture shader literal block.
    tx_%u_%u
<invalid member offset>
// Generated by 
Microsoft (R) D3DX9 Shader Disassembler
<invalid constant table>
// Parameters:
<invalid type offset>
// Registers:
//   Name
 Reg   Size
 ----- ----
 %c%-4u
// Default values:
//   %s
//     %c%-4u= 
<invalid default value offset>
{ %g, %g, %g, %g }
{ %d, %d, %d, %d }
oDepthGE
oDepthLE
rasterizer
vOutputControlPointID
vForkInstanceID
vJoinInstanceID
vDomain
vThreadID
vThreadGroupID
vThreadIDInGroup
vThreadIDInGroupFlattened
vCoverage
vGSInstanceID
vCycleCounter
<unknown register type %u>
%d[%d].
_%d_%d.
(%f, %f)
(%f, %f, %f, %f)
(0x%08x)
undefined
clip_distance
cull_distance
rendertarget_array_index
viewport_array_index
vertex_id
sampleIndex
primitive_id
instance_id
is_front_face
finalQuadUeq0EdgeTessFactor
finalQuadVeq0EdgeTessFactor
finalQuadUeq1EdgeTessFactor
finalQuadVeq1EdgeTessFactor
finalQuadUInsideTessFactor
finalQuadVInsideTessFactor
finalTriUeq0EdgeTessFactor
finalTriVeq0EdgeTessFactor
finalTriWeq0EdgeTessFactor
finalTriInsideTessFactor
finalLineDetailTessFactor
finalLineDensityTessFactor
    preshader
    vs_2_x
    vs_2_sw
    vs_3_sw
    ps_2_x
    ps_2_sw
    ps_3_sw
    vs_%u_%u
    ps_%u_%u
// disassembly only available for VS and PS targets
Error: unexpected end of buffer
    // %s
%u "%s"
reserved0
_volume
_unknown
_position
_blendweight
_blendindices
_normal
_texcoord
_tangent
_binormal
_tessfactor
_positiont
_sample
_centroid
// approximately %u instruction slot%s used
 (%u texture, %u arithmetic)
// incorrect instruction offset in debug info
// incorrect token offset in debug info
// incorrect file offset in debug info
// too many instruction outputs in debug info
// incorrect scalar offset in debug info
// incorrect variable offset in debug info
%s[r%u.%c]<
%s[r%u.%c/%u]<
texture1d
texture2d
texture2dms
texture3d
texturecube
texture1darray
texture2darray
texture2dmsarray
texturecubearray
raw_buffer
structured_buffer
<unknown dimension>
<!-- id=%d -->
           
_indexable
precise
(%i,%i,%i)
, stride=%u
_rcpfloat 
_uglobal
_ugroup
 x%i[%i], %d
 pointlist 
 linestrip 
 trianglestrip 
 undefined 
 point 
 triangle 
 lineadj 
 triangleadj 
 patch1 
 patch2 
 patch3 
 patch4 
 patch5 
 patch6 
 patch7 
 patch8 
 patch9 
 patch10 
 patch11 
 patch12 
 patch13 
 patch14 
 patch15 
 patch16 
 patch17 
 patch18 
 patch19 
 patch20 
 patch21 
 patch22 
 patch23 
 patch24 
 patch25 
 patch26 
 patch27 
 patch28 
 patch29 
 patch30 
 patch31 
 patch32 
 constant 
 linear 
 linear centroid 
 linear noperspective 
 linear noperspective centroid 
 linear sample 
 linear noperspective sample 
cb%d[%d]
, dynamicIndexed
, immediateIndexed
 domain_quad
 domain_tri
 domain_isoline
 partitioning_integer
 partitioning_pow2
 partitioning_fractional_odd
 partitioning_fractional_even
 output_point
 output_line
 output_triangle_cw
 output_triangle_ccw
dcl_immediateConstantBuffer
                              
printf 
errorf 
<unknown> 
undecipherable custom data
_dynamicindexed
 fp%u[%u][%u] = {
 ft%u = {
, %u, %u
 %u, %u, %u
, mode_default
, mode_comparison
, mode_mono
ps_%d_%d
vs_%d_%d
hs_%d_%d
ds_%d_%d
gs_%d_%d
cs_%d_%d
// Available Class Types:
// Name                             ID CB Stride Texture Sampler
// ------------------------------ ---- --------- ------- -------
// %-30s %4u %9u %7u %7u
// Available Class Instances:
// Name                        Type CB CB Offset Texture Sampler
// --------------------------- ---- -- --------- ------- -------
// %-27s %4u 
%2u %9u 
 -         - 
      - 
      -
// Interface slots, %u total:
//             Slots
// +----------+---------+---------------------------------------
// | Type ID  |%4u-%-4u|
// | Type ID  |%4u     |
// | Type ID  |         |
// | Table ID |         |
// %s shader bytecode:
Microsoft (R) D3D Shader Disassembler
// Note: SHADER WILL ONLY WORK WITH THE DEBUG SDK LAYER ENABLED.
Patch Constant
// Pixel Shader runs at sample frequency
XNA Prepass
D3DCOMPILER_DISASSEMBLY_FORCE_HEX_LITERALS
<body bgcolor="#000000">
%s %s = 
%s %s[%d] = 
    asm {
    NULL,
technique10 
    pass 
        // No embedded %s
        %s = %s[%d];
        %s = %s;
        %s = asm {
        %s = NULL;
BorderColor
ComparisonFunc
MaxAnisotropy
MipLODBias
AddressW
AddressV
AddressU
RenderTargetWriteMask
BlendOpAlpha
DestBlendAlpha
SrcBlendAlpha
BlendOp
DestBlend
SrcBlend
BlendEnable
AlphaToCoverageEnable
BackFaceStencilFunc
BackFaceStencilPass
BackFaceStencilDepthFail
BackFaceStencilFail
FrontFaceStencilFunc
FrontFaceStencilPass
FrontFaceStencilDepthFail
FrontFaceStencilFail
StencilWriteMask
StencilReadMask
StencilEnable
DepthFunc
DepthWriteMask
DepthEnable
AntialiasedLineEnable
MultisampleEnable
ScissorEnable
DepthClipEnable
SlopeScaledDepthBias
DepthBiasClamp
DepthBias
FrontCounterClockwise
CullMode
FillMode
AB_SampleMask
AB_BlendFactor
DS_StencilRef
GenerateMips
REV_SUBTRACT
SUBTRACT
DECR_SAT
INCR_SAT
REPLACE
GREATER_EQUAL
NOT_EQUAL
GREATER
LESS_EQUAL
MIRROR_ONCE
INV_SRC1_ALPHA
SRC1_ALPHA
INV_SRC1_COLOR
SRC1_COLOR
INV_BLEND_FACTOR
BLEND_FACTOR
SRC_ALPHA_SAT
INV_DEST_COLOR
DEST_COLOR
INV_DEST_ALPHA
DEST_ALPHA
INV_SRC_ALPHA
SRC_ALPHA
INV_SRC_COLOR
SRC_COLOR
TEXT_1BIT
COMPARISON_ANISOTROPIC
COMPARISON_MIN_MAG_MIP_LINEAR
COMPARISON_MIN_MAG_LINEAR_MIP_POINT
COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR
COMPARISON_MIN_LINEAR_MAG_MIP_POINT
COMPARISON_MIN_POINT_MAG_MIP_LINEAR
COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT
COMPARISON_MIN_MAG_POINT_MIP_LINEAR
COMPARISON_MIN_MAG_MIP_POINT
ANISOTROPIC
MIN_MAG_MIP_LINEAR
MIN_MAG_LINEAR_MIP_POINT
MIN_LINEAR_MAG_POINT_MIP_LINEAR
MIN_LINEAR_MAG_MIP_POINT
MIN_POINT_MAG_MIP_LINEAR
MIN_POINT_MAG_LINEAR_MIP_POINT
MIN_MAG_POINT_MIP_LINEAR
MIN_MAG_MIP_POINT
WIREFRAME
[%s[%u + %s].%c]
[%s[%s].%c]
[%s[%u].%c]
[%s.%c]
%s[%u +
Error: Effects expression assembly in invalid format!
Error: Effects expression assembly not found!
Error: Error getting Effects expression constant table.
Error: Error getting Effects expression literal block.
##Internal error##
 : packoffset(c%u.%c)
 : register(%c%u)
 = { "%s"
 = "%s"
// Offset: %4u, size: %4u
// %u %s buffer(s)
single 
/* Stream %u out decl: "%s" */
/* Stream %u to rasterizer */
/* Interface parameter %u bound to: %s
%s[eval(
/* Stream out decl: "%s" */
// %u %s object(s)
// %u %s interface(s)
// %u technique(s)
technique11
technique10
// %u groups(s)
fxgroup
// FX Version: %s
// Child effect (requires effect pool): %s
bool4x4
bool4x3
bool4x2
bool4x1
bool3x4
bool3x3
bool3x2
bool3x1
bool2x4
bool2x3
bool2x2
bool2x1
bool1x4
bool1x3
bool1x2
bool1x1
uint4x4
uint4x3
uint4x2
uint4x1
uint3x4
uint3x3
uint3x2
uint3x1
uint2x4
uint2x3
uint2x2
uint2x1
uint1x4
uint1x3
uint1x2
uint1x1
float4x4
float4x3
float4x2
float4x1
float3x4
float3x3
float3x2
float3x1
float2x4
float2x3
float2x2
float2x1
float1x4
float1x3
float1x2
float1x1
D3DEffectCompiler
MIPLODBIAS
MIPMAPLODBIAS
MIPFILTER
MINFILTER
MAGFILTER
DMAPOFFSET
ELEMENTINDEX
SRGBTEXTURE
MAXMIPLEVEL
$Globals
register or offset bind %s.%s not valid
register or offset bind %s not valid
Internal Error - there was a problem getting a type size
There was an unexpected error in the parse tree
Variable has an invalid type; is the structure definition empty?
%s does not support structs without members
interfaces cannot be embedded in other types
Incorrect number of rows or columns
Objects not allowed in structures
Only single-dimensional object arrays are allowed
Unexpected template type
RWTexture1D
RWTexture1DArray
RWTexture2D
RWTexture2DArray
RWTexture3D
RWBuffer
ByteAddressBuffer
RWByteAddressBuffer
StructuredBuffer
RWStructuredBuffer
AppendStructuredBuffer
ConsumeStructuredBuffer
SamplerComparisonState
Unexpected component type
Unexpected node encountered when trying to determine type
There was a problem getting annotations
Only numeric types and strings are allowed as annotations
This object can only be bound to one slot in this version of Effects
Numeric variables ('%s') can't be shared; share the containing cbuffer instead
Only numeric variables ('%s') can be added to a cbuffer
Error: constant buffer %s has both user-defined offset and compiler-assigned offsets
Buffers can only be bound to one slot in this version of Effects
Constant buffers, functions, and techniques cannot be nested inside of constant buffers
Unnamed objects are not allowed
Redefinition of pass "%s"
Rasterizer
DepthStencil
Sampler
<unknown>
DX9-style assignment syntax is deprecated in technique10 pass blocks in favor of new function call syntax
Deprecated DX9 state '%s' is being ignored for %s
Deprecated DX9 state '%s' is being ignored for %s; use state '%s' instead
DX9 state '%s' is not supported in %s; use compatibility mode to ignore
DX9 state '%s' is not supported in %s; convert to '%s' or use compatibility mode to ignore
Unrecognized state '%s'
State '%s' belongs in %s blocks, not %s blocks
GenerateMips is not supported in %s
State '%s' is not indexed
Max index for effect state '%s' is %d
Index is required for state '%s'
SetComputeShader
SetDomainShader
SetHullShader
Internal error: unrecognized SB API Call
%s is not supported on %s
Internal error: unrecognized assignment type
(unnamed)
SV_IsFrontFace
SV_SampleIndex
ERROR: Semantic %s is not supported in fx_4_1.
Stage linkage warning: Semantic %s has been placed in different registers in the two stages.
Stage linkage warning: Semantic %s has been inconsistently defined in the two stages.
Stage linkage warning: Semantic %s is read from, but it's never written to.
%s: ERROR: If either a HullShader or DomainShader is set then both must be set. Technique %s, Pass %s.
%s: ERROR: No valid %s-%s combination could be found in Technique %s, Pass %s.
%s: WARNING: There exist invalid %s-%s combinations in Technique %s, Pass %s, depending on which elements of the specified shader array(s) are chosen.
'%s': samplers can only be used with declared textures or texture assignments
Assignment %s: Reference to shader variable '%s' not valid for %s techniques because it uses an uninitialized shader
Assignment %s: Reference to shader variable '%s' not valid for %s techniques because it uses an unsupported shader model
Assignment %s: Reference to shader variable '%s' not valid for %s techniques because it is missing interface parameter bindings
Unrecognized RHS value in assignment: '%s'
There was an error compiling HLSL shader variable
Undefined shader variable '%s'
%s can't operate on array references
Stream output geometry shaders can only be created from valid 4.0+ vertex and geometry shaders
%s can only be used with non-NULL shaders
Invalid shader type used with %s
Identifier invalid or not found (were you attempting a forward reference?)
%s does not support multi-output stream out
StreamOut declarations must be a literal string
Invalid StreamOut decl: %s
Invalid StreamOut decl
StreamOut rasterization stream index must be a literal
ConstructGSWithSO
%s does not support interface bindings
invalid interface binding parameter
cannot bind interfaces to classes in tbuffers
BindInterfaces
BindInterfaces used with a shader that does not have interface parameters
Incorrect number of parameters for BindInterfaces
interface variables can only be initialized with concrete classes
Illegal initializer for a numeric variable
Can't create/set an invalid shader. Make sure your shader is valid, and make sure you're not using asm shaders in SM4.0
Illegal initializer
Unrecognized token %s
Internal error in compiler
Shader model %s is not allowed in D3D10 techniques
There was an error compiling expression
Assignment %s: Non-array right-hand type expected
Assignment %s: Only literal right-hand side values are allowed in state blocks in Effects performance mode
Assignment %s: Left-hand side type does not match right-hand side type
Assignment %s: Attempting to assign an incompatible inline shader
Assignment %s: Inline shader missing interface parameter bindings
Assignment %s: Only 0 and NULL are valid constants for an object assignment
Assignment %s: Dimensionality mismatch (LHS expects %d, RHS has %d)
Invalid assignment index (%u). Maximum allowed is %u.
TEXTURE assignments inside of samplers cannot be variable indexed
TEXTURE assignments inside of samplers cannot be expression indexed
Assignment %s: Expressions cannot be evaluated to produce objects, though they may be used to index into arrays of objects
Assignment %s: Objects left-hand sides cannot be assigned to expressions
Effect file is too large, try reducing the number of techniques or compiling without debug info
SV_PrimitiveID
ID3D10Effect::ParseSODecl - invalid mask declaration '%s'
ID3D10Effect::ParseSODecl - Invalid output slot
ID3D10Effect::ParseSODecl - Non-digit '%c' in output slot
$PRESHADER_PS
$PRESHADER_VS
STATEBLOCK
SAMPLER
MAXANISOTROPY
BORDERCOLOR
ADDRESSW
ADDRESSV
ADDRESSU
PIXELSHADERCONSTANT4
PIXELSHADERCONSTANT3
PIXELSHADERCONSTANT2
PIXELSHADERCONSTANT1
PIXELSHADERCONSTANT
PIXELSHADERCONSTANTI
PIXELSHADERCONSTANTB
PIXELSHADERCONSTANTF
VERTEXSHADERCONSTANT4
VERTEXSHADERCONSTANT3
VERTEXSHADERCONSTANT2
VERTEXSHADERCONSTANT1
VERTEXSHADERCONSTANT
VERTEXSHADERCONSTANTI
VERTEXSHADERCONSTANTB
VERTEXSHADERCONSTANTF
PIXELSHADER
VERTEXSHADER
LIGHTENABLE
LIGHTPHI
LIGHTTHETA
LIGHTATTENUATION2
LIGHTATTENUATION1
LIGHTATTENUATION0
LIGHTFALLOFF
LIGHTRANGE
LIGHTDIRECTION
LIGHTPOSITION
LIGHTAMBIENT
LIGHTSPECULAR
LIGHTDIFFUSE
LIGHTTYPE
MATERIALPOWER
MATERIALEMISSIVE
MATERIALSPECULAR
MATERIALAMBIENT
MATERIALDIFFUSE
TEXTURETRANSFORM
WORLDTRANSFORM
VIEWTRANSFORM
PROJECTIONTRANSFORM
PATCHSEGMENTS
TEXTURETRANSFORMFLAGS
BUMPENVLOFFSET
BUMPENVLSCALE
TEXCOORDINDEX
BUMPENVMAT11
BUMPENVMAT10
BUMPENVMAT01
BUMPENVMAT00
RESULTARG
ALPHAARG2
ALPHAARG1
ALPHAARG0
ALPHAOP
COLORARG2
COLORARG1
COLORARG0
COLOROP
BLENDOPALPHA
DESTBLENDALPHA
SRCBLENDALPHA
SEPARATEALPHABLENDENABLE
DEPTHBIAS
SRGBWRITEENABLE
COLORWRITEENABLE3
COLORWRITEENABLE2
COLORWRITEENABLE1
CCW_STENCILFUNC
CCW_STENCILPASS
CCW_STENCILZFAIL
CCW_STENCILFAIL
TWOSIDEDSTENCILMODE
ENABLEADAPTIVETESSELLATION
ADAPTIVETESS_W
ADAPTIVETESS_Z
ADAPTIVETESS_Y
ADAPTIVETESS_X
MAXTESSELLATIONLEVEL
MINTESSELLATIONLEVEL
ANTIALIASEDLINEENABLE
SLOPESCALEDEPTHBIAS
SCISSORTESTENABLE
NORMALDEGREE
POSITIONDEGREE
BLENDOP
TWEENFACTOR
COLORWRITEENABLE
INDEXEDVERTEXBLENDENABLE
DEBUGMONITORTOKEN
PATCHEDGESTYLE
MULTISAMPLEMASK
MULTISAMPLEANTIALIAS
POINTSCALE_C
POINTSCALE_B
POINTSCALE_A
POINTSCALEENABLE
POINTSPRITEENABLE
POINTSIZE_MAX
POINTSIZE_MIN
POINTSIZE
CLIPPLANEENABLE
VERTEXBLEND
EMISSIVEMATERIALSOURCE
AMBIENTMATERIALSOURCE
SPECULARMATERIALSOURCE
DIFFUSEMATERIALSOURCE
NORMALIZENORMALS
LOCALVIEWER
COLORVERTEX
FOGVERTEXMODE
AMBIENT
LIGHTING
CLIPPING
TEXTUREFACTOR
STENCILWRITEMASK
STENCILMASK
STENCILREF
STENCILFUNC
STENCILPASS
STENCILZFAIL
STENCILFAIL
STENCILENABLE
RANGEFOGENABLE
FOGDENSITY
FOGSTART
FOGTABLEMODE
FOGCOLOR
SPECULARENABLE
FOGENABLE
ALPHABLENDENABLE
DITHERENABLE
ALPHAFUNC
ALPHAREF
CULLMODE
DESTBLEND
SRCBLEND
LASTPIXEL
ALPHATESTENABLE
ZWRITEENABLE
SHADEMODE
FILLMODE
ZENABLE
TEXCOORDSIZE4_7
TEXCOORDSIZE4_6
TEXCOORDSIZE4_5
TEXCOORDSIZE4_4
TEXCOORDSIZE4_3
TEXCOORDSIZE4_2
TEXCOORDSIZE4_1
TEXCOORDSIZE4_0
TEXCOORDSIZE3_7
TEXCOORDSIZE3_6
TEXCOORDSIZE3_5
TEXCOORDSIZE3_4
TEXCOORDSIZE3_3
TEXCOORDSIZE3_2
TEXCOORDSIZE3_1
TEXCOORDSIZE3_0
TEXCOORDSIZE2_7
TEXCOORDSIZE2_6
TEXCOORDSIZE2_5
TEXCOORDSIZE2_4
TEXCOORDSIZE2_3
TEXCOORDSIZE2_2
TEXCOORDSIZE2_1
TEXCOORDSIZE2_0
TEXCOORDSIZE1_7
TEXCOORDSIZE1_6
TEXCOORDSIZE1_5
TEXCOORDSIZE1_4
TEXCOORDSIZE1_3
TEXCOORDSIZE1_2
TEXCOORDSIZE1_1
TEXCOORDSIZE1_0
LASTBETA_D3DCOLOR
LASTBETA_UBYTE4
DIRECTIONAL
PROJECTED
GAUSSIANQUAD
PYRAMIDALQUAD
ALPHAREPLICATE
COMPLEMENT
CONSTANT
TFACTOR
TEXTURE
CURRENT
SELECTMASK
MULTIPLYADD
DOTPRODUCT3
BUMPENVMAPLUMINANCE
BUMPENVMAP
MODULATEINVCOLOR_ADDALPHA
MODULATEINVALPHA_ADDCOLOR
MODULATECOLOR_ADDALPHA
MODULATEALPHA_ADDCOLOR
PREMODULATE
BLENDCURRENTALPHA
BLENDTEXTUREALPHAPM
BLENDFACTORALPHA
BLENDTEXTUREALPHA
BLENDDIFFUSEALPHA
ADDSMOOTH
ADDSIGNED2X
ADDSIGNED
MODULATE4X
MODULATE2X
MODULATE
SELECTARG2
SELECTARG1
SPHEREMAP
CAMERASPACEREFLECTIONVECTOR
CAMERASPACEPOSITION
CAMERASPACENORMAL
PASSTHRU
REVSUBTRACT
CLIPPLANE5
CLIPPLANE4
CLIPPLANE3
CLIPPLANE2
CLIPPLANE1
CLIPPLANE0
TWEENING
3WEIGHTS
2WEIGHTS
1WEIGHTS
0WEIGHTS
DISABLE
CONTINUOUS
DISCRETE
QUINTIC
QUADRATIC
MATERIAL
DECRSAT
INCRSAT
GREATEREQUAL
NOTEQUAL
LESSEQUAL
MIRRORONCE
INVBLENDFACTOR
BLENDFACTOR
BOTHINVSRCALPHA
BOTHSRCALPHA
SRCALPHASAT
INVDESTCOLOR
DESTCOLOR
INVDESTALPHA
DESTALPHA
INVSRCALPHA
SRCALPHA
INVSRCCOLOR
SRCCOLOR
GOURAUD
ID3DXEffectCompiler: Unexpected template type
ID3DXEffectCompiler: Unexpected component type
ID3DXEffectCompiler: Unexpected node encountered when trying to determine type
ID3DXEffectCompiler: There was an error initializing parameter handles
ID3DXEffectCompiler: There was an error initializing parameter annotation handles
ID3DXEffectCompiler: There was an error initializing technique annotation handles
ID3DXEffectCompiler: There was an error initializing pass annotation handles
ID3DXEffectCompiler: There was an error initializing the compiler
ID3DXEffectCompiler: There was a problem getting variable type
ID3DXEffectCompiler: Error initializing variable type
ID3DXEffectCompiler: There was a problem in the parse tree
ID3DXEffectCompiler: There was a problem getting annotations
ID3DXEffectCompiler: Only numeric types and strings are allowed as annotations
ID3DXEffectCompiler: Error initializing annotation type
ID3DXEffectCompiler: Only numeric types are allowed inside structures
ID3DXEffectCompiler: Arrays must be either numeric, structure, string or shader
ID3DXEffectCompiler: Only pass allowed within a technique
ID3DXEffectCompiler: Unrecognized state '%s'
ID3DXEffectCompiler: State '%s' is not indexed
ID3DXEffectCompiler: Max index for effect state '%s' is %d
ID3DXEffectCompiler: Index is required for state '%s'
ID3DXEffectCompiler: DMAPOFFSET sampler state can only be used with D3DDMAPSAMPLER (i.e. sampler index 256)
ID3DXEffectCompiler: Invalid sampler index %d
ID3DXEffectCompiler: Invalid integer expression assignment
ID3DXEffectCompiler: Unsupported sampler or stateblock expression (static usage not supported).
ID3DXEffectCompiler: Can't set shader'
ID3DXEffectCompiler: Geometry shader can only be set in fx_4_0 or higher.'
ID3DXEffectCompiler: Internal Error: Unexpected state.
ID3DXEffectCompiler: Initializer list elements cannot be complex expressions or variables
ID3DXEffectCompiler: Unexpected error
ID3DXEffectCompiler: Error in type checking
ID3DXEffectCompiler: State '%s' does not accept '%s' as a value
ID3DXEffectCompiler: State '%s' accepts only dwords and ids
ID3DXEffectCompiler: FVFs must not evaluate to NULL
ID3DXEffectCompiler: Dword expressions for state '%s' must evaluate to NULL
ID3DXEffectCompiler: State '%s' was assigned an unsupported value
ID3DXEffectCompiler: Error initializing assignment type
ID3DXEffectCompiler: Internal error initializing assignment - missing type case
ID3DXEffectCompiler: Assignment cannot be a structure
ID3DXEffectCompiler: Initializers must be numeric scalars
ID3DXEffectCompiler: State '%s' cannot be assigned an array or structure
ID3DXEffectCompiler: State '%s' was not assigned a stateblock type
ID3DXEffectCompiler: State '%s' was not assigned a sampler type
ID3DXEffectCompiler: State '%s' was not assigned a texture type
ID3DXEffectCompiler: State '%s' was assigned an incompatible type
ID3DXEffectCompiler: State '%s' must be assigned a numeric scalar or a 4-float vector
ID3DXEffectCompiler: State '%s' must be assigned a scalar
ID3DXEffectCompiler: State '%s' must be assigned a 3-vector or a 4-vector or a uint scalar
ID3DXEffectCompiler: State '%s' must be assigned a numeric value
ID3DXEffectCompiler: Unexpected value type of state '%s' (internal error)
ID3DXEffectCompiler::CompileEffect: There was an error compiling HLL shader parameter
ID3DXEffectCompiler::CompileEffect: Unrecognized value type
ID3DXEffectCompiler::CompileEffect: Only 1-d shader arrays allowed
ID3DXEffectCompiler::CompileEffect: Shader arrays must be a previously defined parameter
ID3DXEffectCompiler::CompileEffect: Shader arrays index was not float or int
ID3DXEffectCompiler::CompileEffect: Shader arrays index %d out of bounds [0, %d]
ID3DXEffectCompiler::CompileEffect: There was an error compiling expression
ID3DXEffectCompiler::CompileEffect: Could not compile expression containing shader array
ID3DXEffectCompiler: There were no techniques
ID3DXEffectCompiler: This sampler is used with a DX10-style texture intrinsic. This is not implemented in this version of the compiler.
ID3DXEffectCompiler: Compilation failed
Output variable 
%s%s contains a system-interpreted value (%s) which must be written in every execution path of the shader <| A%u (B%u)
%s%s contains a system-interpreted value (%s) which should be written in every execution path of the shader <| A%u (B%u)
emitting a system-interpreted value which is not written in every execution path of the shader <| A%u (B%u)
emitting a system-interpreted value which may not be written in every execution path of the shader <| A%u (B%u)
Inconsistent semantic definition: %s and %s
Duplicate system value semantic definition: %s and %s
Duplicate non-system value semantic definition: %s and %s
Reading uninitialized value
maximum number of samplers exceeded. %s target can have a maximum of %u samplers
%s target does not support texture lookups
internal error: output register missing semantic
internal error: input register missing semantic
?internal error: emitting a denorm
NaN and infinity literals not allowed by shader model
maximum number of inputs exceeded
overlapping output semantics
internal error: statistics append failed, byte count (%d) too large?
internal error: non ordinal input/output found
maximum cbuffer exceeded. target has %u slots, manual bind to slot %u failed
cbuffer bank %u used more than once
maximum cbuffer exceeded. target has %u slots
boolean
constant
iterator
 - Try reducing number of constant branches, take bools out of structs/arrays or move them to the start of the struct
 - Try reducing number of constants referenced
 - Try reducing number of loops, take loop counters out of structs/arrays or move them to the start of the struct
 - note that the target doesn't support texture sampling intrinsics
 - note that the target doesn't support textures
 - note that the target doesn't support UAVs
maximum %s %s register index (%u) exceeded - note that the minimum index is %u%s
maximum %s %s register index (%u) exceeded%s
invalid register semantic '%s', or variable must be bound to multiple register banks (%c register binding required)
%s registers live in the same name space as outputs, so they must be bound to at least %c%u, manual bind to slot %s failed
maximum %s register index exceeded, target has %d slots, manual bind to slot %s failed
overlapping register semantics not yet implemented '%c%u'
Using sampler arrays with texture objects on DX9 targets is not yet implemented.
Cannot use texture arrays on DX9 targets with multiple samplers.
Invalid %s semantics - POSITIONT0
invalid %s %s
, or '%s'
one of '%s'
Sample interpolation usage unsupported on %s
nointerpolation usage unsupported on %s
noperspective usage unsupported on %s
SV_SampleIndex isn't supported on %s
Maximum semantic index (%d) exceeded: %d
%s semantic '%s' cannot be centroid
%s semantic '%s' has been deprecated; use '%s%d' instead
invalid %s semantic '%s': Legal indices are in [%d,%d]
invalid type used for '%s' %s semantics
integral
invalid type used for '%s' %s semantics, must be %s
internal error: result violated port constraints
internal error: non-vectorized pool violated port constraints
relative address references too deep
internal error: multiple write to same output
cannot match lerp because lerp factor is not _sat'd
internal error: instruction missing outputs
internal error: IF with size greater then 1 found
cannot clip from a swizzled vector
clip must be performed from a float3 vector for ps_1_x models
clip must be performed from a float4 vector for ps_2_0 models
internal error: unexpected input register type
clip cannot be performed from a constant or literal
constant table info exceeds maximum comment size
Microsoft (R) HLSL Shader Compiler 9.29.952.3111
maximum temp register index exceeded
maximum address register index exceeded
maximum predicate register index exceeded
internal error: unexpected output register type
internal error: overlapping output writes
maximum input register index exceeded
maximum constant register index exceeded - Try reducing number of constants referenced
maximum bool register index exceeded
maximum sampler register index exceeded
maximum loop register index exceeded
target does not support relative addressing
tessfactor semantic out of order
conflicting quad/tri/isoline tessfactor semantic
tessfactor semantics must be in the same component
%s output limit (%d) exceeded, shader uses %d outputs.
%s input limit (%d) exceeded, shader uses %d inputs.
internal error: no semantic found on i/o argument
Semantic length is limited to %d characters
internal error: output found with no semantic
SV_Position
SV_Target
semantic '%s' unsupported on %s
output %s%u used more than once
integer inputs unsupported on %s
Not all elements of SV_Position were written
tessfactor inputs missing
Clip planes cannot be addressed in %s
Clip planes must be non-literal constants with identity swizzles in %s
Unsized MSAA textures aren't supported on this target
TextureCubeArray textures aren't supported on this target
texture2DMS cannot be more than 127 samples
Texture1D types are unsupported on %s
texture mismatch: texture used inconsistently, can only use one DX9-style texture intrinsic on individual samplers or sampler arrays
$Element
RWStructuredBuffers may increment or decrement their counters, but not both.
The array element count of GetDimensions on TextureCubeArray objects is unavailable on %s
cannot sample from non-floating point texture formats.
sampler mismatch: sampler used inconsistently
d3ds_dotswiz
d3ds_noiseswiz
fxl_2_0
too many arguments to target TX
too many outputs to target TX
clip not supported in texture shaders
invalid reference to input semantic '%s%d'
invalid reference to output semantic '%s%d'
internal error: gradient instruction sent to preshader
fxl_4_0
SV_GroupIndex
SV_DispatchThreadID
SV_GroupThreadID
SV_GroupID
SV_DomainLocation
SV_InsideTessFactor
SV_TessFactor
SV_OutputControlPointID
SV_GSInstanceID
SV_ViewportArrayIndex
SV_RenderTargetArrayIndex
SV_VertexID
SV_InstanceID
SV_CullDistance
SV_ClipDistance
Position
Failed to log error, redirecting to debug output:
hs_5_0 patch constant
hs_5_0 control point
Sum of temp registers and indexable temp registers exceeds limit of %u
sum of temp registers and indexable temp registers times %u threads exceeds the recommended total %u.  Performance may be reduced
The total amount of group shared memory (%u bytes) exceeds the %s limit of %d bytes
internal error gathering debug scope information
internal error gathering debug variable information
internal error gathering debug input information
internal error gathering debug file information
Maximum %s control point count (%u) exceeded (%u).
internal error: debug info append failed, byte count (%d) too large?
internal error: scalar instruction with too many inputs
internal error: expected binary instruction for scalar RHS
maximum number of interface pointers exceeded (%s max is %u)
interface calls cannot be indexed with varying values
%s can only emit to streams 0-%u
%s can only emit to 1 stream
%s does not support stream out
geometry shader didn't emit anything
when multiple GS output streams are used they must be pointlists
Shaders compiled for %s can only have a single group shared data item
Group shared data for %s must have a count of elements (%u) equal to the number of threads in the thread group (%u)
Group shared data for %s must have an element size (%u) of at most %u bytes when compiling for %u theads
Group shared data for %s must be an array of elements
internal error: modifier used on address
internal error: Constant buffer used as address
internal error: binary instruction expected
internal error: vectorized instruction too large
internal error: expected scalar RHS for instruction
%s does not support structured buffers
structured buffer element size must be a multiple of %u bytes in %s (actual size %u bytes)
structured buffer elements cannot be larger than %u bytes in %s (actual size %u bytes)
offset texture instructions must take offset which can resolve to integer literal in the range -8 to 7
MSAA Sample Index must be in the range 0 to 127
MSAA Sample Index must be a literal
Sample Bias value is limited to the range [-16.00, 15.99], using %f instead of %f
%s does not support UAVs
%s does not support Append/Consume buffers
%s does not support typed UAVs
idiv currently not supported (instruction deprecated). For now, try using unsigned int types for div instead
typed UAV stores must write all declared components.
stores to group shared memory for %s targets must be indexed by an SV_GroupIndex only
%s snap offset must be in the range -8 to 7
cannot map expression to %s instruction set
internal error: failed to emit instruction
SV_Position cannot be constinterp
SV_Coverage input not supported on %s
SV_Coverage not supported on %s
invalid semantic '%s' on pixel shader output
Tessfactor
Specular
Diffuse
PositionT
Binormal
Tangent
Texcoord
BlendIndices
BlendWeight
internal error: no profile exists for this shader version
PSIZE must be a scalar
vertex shader must minimally write all four components of POSITION
DEPTH must be a scalar
pixel shader must minimally write all four components of COLOR0
COLOR%d must be a four-component vector
COLOR outputs must be contiguous from COLOR0 to COLORn
cannot map expression to vertex shader instruction set
cannot map expression to pixel shader instruction set
Unsupported texture type for %s
internal error: unexpected Alias on texture declaration
relative addressing not supported in vs_1_0 instruction set
internal error: no profile exists for this pixel shader version
SV_Target0
pixel shader must minimally write all four components of %s
%s%d must be a four-component vector
SV_Target outputs must be contiguous from SV_Target0 to SV_TargetN
relative addressing not allowed for pixel shaders
texlod not supported on this target
Shader model %s doesn't allow reading from position semantics.
Invalid %s input semantic '%s'.
sample interpolation usage unsupported on %s
internal error: invalid swizzle found
SV_Color
internal error: no profile exists for this vertex shader version
FOG must be a scalar
vertex shader must minimally write all four components of SV_Position
internal error: DST test failure
allow_uav_condition
a uint specifying the number of iterations to unroll
fastopt
forcecase
flatten
pEntrypoint pointer is invalid
internal error: expression expected
expressions returning objects in an array or struct not yet implemented
compile expression does not refer to a compilable function.  API calls such as ConstructGSWithSO and BindInterfaces can not be used in arguments to CompileShader
compile expression must specify a valid shader model
asm blocks have not yet been implemented
non-trivial object expressions not yet implemented
'%s': entrypoint not found
overloaded function not found
internal error: blob mismatch between level9 and d3d10 shader
internal error: blob size mismatch between level9 and d3d10 shader
internal error: blob content mismatch between level9 and d3d10 shader
D3DCOMPILER_FORCE_PREFER_FLOW
Flags parameter is invalid
Flags specified both compatibility and strict mode. These are mutually exclusive
Flag specified was exclusively a parse flag and not a compile flag
ppShader pointer is invalid
unrecognized compiler target '%s'
vs_2_sw
vs_3_sw
ps_2_sw
ps_3_sw
Only 3_x and earlier targets are supported on this compiler.
Only 4_x targets supported on this compiler.
ps_1_x is no longer supported; using ps_2_0
ps_1_x is no longer supported; use /Gec in fxc to automatically upgrade to ps_2_0
Alternately, fxc's /LD option allows use of the old compiler DLL
internal error: compilation aborted unexpectedly
cinstanceid
'%s': variable declared but not defined
%s does not support groupshared, groupshared ignored
'%s': global variables cannot use the 'half' type in %s. To treat this variable as a float, use the backwards compatibility flag.
'%s': %s does not support doubles as a storage type
'%s': %s does not support 8-bit or 16-bit integers
'%s': %s does not support 64-bit integers
invalid packoffset location '%s'
groupshared variables cannot contain resources such as textures, samplers or UAVs
cannot mix packoffset elements with nonpackoffset elements in a cbuffer
stream object '%s' cannot be declared in the global scope
internal error: unrecognized statement
Texture sample will be considered dependent since texcoord was not declared as at least float%d
DX9-style intrinsics are disabled when not in dx9 compatibility mode.
expressions with side effects are illegal as attribute parameters
non-literal parameter(s) found for attribute %s
cannot match attribute %s, non-uint parameters found
attribute %s expects the %s parameter to be a %s
'%s(%s)' attribute expected, where '%s' is %s
'%s(%s)' attribute expected, where '%s' are %s
expected %s parameter to be %s, got '%s'
cannot match attribute %s, parameter %i is expected to be of type %s%c
can't match attribute %s, %d or 0 parameters expected, found %d
can't match attribute %s, %d parameter(s) expected, found %d
unknown attribute %s, or attribute invalid for this statement
unknown attribute %s, or attribute invalid for this statement, valid attributes are: %s
duplicate attribute %s
Cannot use %s attribute without specifying a 4-component SV_Position output
doubles cannot be used as shader inputs or outputs. If you need to pass a double between shader stages you must pass it as two uints and use asuint and asdouble to convert between forms
stream parameter must come from a literal expression
structure being emitted has elements with no semantic defined
%s does not support synchronization operations
%s does not support thread synchronization operations
thread synchronization operations cannot be used in varying flow control
signed/unsigned mismatch between destination and value, unsigned assumed
%s does not support interlocked operations
%s only supports interlocked operations on scalar int or uint data
interlocked targets must be groupshared or UAV elements
%s does not support pull-model attribute evaluation
attribute evaluation can only be done on values taken directly from inputs
%s does not support pull-model evaluation of position
'%s': undefined variable
invalid variable reference in static variable initializer.  Locals cannot be used to initialize static variables
internal error: invalid access of unbound variable
internal error: unrecognized value
out of memory
all template type components must have the same type
unexpected error in GetTypeArgFlags
invalid register specification, expected 'b' or 'c' binding
invalid register specification, expected 't' binding
User defined %s buffer slots cannot be target specific
Buffers may only be bound to one slot.
Buffers may only be bound to one constant offset.
internal warning: loop values did not converge
Cannot declare streams as an input for geometry shader primitives, it must be its own parameter.
SV_PrimitiveId is an invalid input semantic for geometry shader primitives, it must be its own parameter.
SV_GSInstanceID is an invalid input semantic for geometry shader primitives, it must be its own parameter.
for better compilation results, consider re-enabling rule "%s"
for better compilation results, consider re-enabling rule 0x%08x
, forcing loop to unroll
out of memory while parsing
Illegal character in shader file
asm_fragment
column_major
compile
compile_fragment
const_cast
continue
CompileShader
default
discard
dynamic_cast
explicit
groupshared
InputPatch
lineadj
LineStream
mutable
nointerpolation
namespace
noperspective
operator
OutputPatch
packoffset
private
protected
pixelshader
the 'pixelshader' keyword is deprecated and reserved in strict mode
PointStream
register
reinterpret_cast
row_major
sampler_state
stateblock_state
static_cast
stateblock
template
triangle
triangleadj
typedef
typename
technique
texture1D
texture2D
texture3D
textureCUBE
alternate cases for 'Texture1D' are deprecated in strict mode
alternate cases for 'Texture2D' are deprecated in strict mode
alternate cases for 'Texture3D' are deprecated in strict mode
alternate cases for 'TextureCube' are deprecated in strict mode
TriangleStream
uniform
unsigned
virtual
volatile
vertexshader
the 'vertexshader' keyword is deprecated and reserved in strict mode
alternate cases for 'asm' are deprecated in strict mode
alternate cases for 'decl' are deprecated in strict mode
alternate cases for 'pass' are deprecated in strict mode
alternate cases for 'technique' are deprecated in strict mode
version token
token '%s'
integer constant
float constant
string constant
end of line
end of file
syntax error: unexpected %s
implicitly 
output parameter 
cannot %sconvert %sfrom '%s' to '%s'
'%s': cannot %sconvert %sfrom '%s' to '%s'
'%s': conversion from larger type to smaller, possible loss of data
conversion from larger type to smaller, possible loss of data
'%s': implicit truncation of vector type
implicit truncation of vector type
%s%s%c%s%s
%s%s%cx%c%s%s
%s%s%s%s
<parse error>
packoffset is only allowed in a constant buffer
'%s': invalid shader target/usage
register offset must be a literal scalar expression
parameter list
struct/class
for loop
state block
annotation
default value
<method>
initializer
initial value
<container>
function parameters
methods
struct/class members
loop variables
members
annotation members
local variables
global variables
function
variable
invalid
<symobj>
(unknown scope entry kind)
(unknown scope value kind)
<unnamed>
'%s': identifier represents a %s, not a variable
internal error: unable to process intrinsic
'%s': identifier represents a %s, not a function
'%s': ambiguous function call
globallycoherent
unrecognized identifier '%s'
'%s': too many target specifiers given
duplicate usages specified
constinterp usage cannot be used with linear, noperspective, or centroid usage
conflicting geometry types
AttrParams
$clip_outputs
Attributes
location semantics do not apply to %ss
location semantics cannot be specified on members
packoffset cannot have a target qualifier
usage semantics do not apply to %ss
duplicate usage semantic ignored
redefinition of '%s'
'%s': %s cannot be target specific
'%s': %s cannot be declared 'inline'
'%s': %s cannot be declared 'single'
'%s': interfaces cannot contain data
'%s': interfaces cannot be declared in buffers
'%s': extern %s cannot be declared 'static'
'%s': uniform %s cannot be declared 'static'
'%s': extern %s cannot be declared 'groupshared'
'%s': uniform %s cannot be declared 'groupshared'
'%s': types cannot contain members of their own type
'%s': interfaces cannot be members
'%s': %s cannot be declared 'const'
'%s': output parameters cannot be declared 'const'
'%s': %s cannot be void
'%s': %s cannot be declared 'static'
'%s': %s cannot be declared 'uniform'
'%s': %s cannot be declared 'uniform out'
'%s': %s cannot be declared 'extern'
'%s': %s cannot be declared 'groupshared'
'%s': %s cannot be declared 'shared'
'%s': %s cannot be declared 'volatile'
'%s': array dimensions of %s must be explicit
'%s': implicit array missing %s
'%s': implicit array type does not match %s
'%s': array dimension must be between 1 and 65536
redefinition of formal parameter '%s'
'%s': static members can only be defined in global scopes
'%s': static member not found in class
'%s': member not a static variable
'%s': declaration type differs from definition type
Conflicting register semantics: '%s' and '%s'
'%s': interfaces cannot have semantics
'%s': %s cannot have semantics
'%s': %s cannot have annotations
stream parameters can only be single-element types
'%s': out parameters cannot have default values
potentially unintended use of a comma expression in a variable initializer
'%s': %s cannot have %ss
'%s': non-numeric uniform %s cannot have %ss
'%s': output only %s cannot have %ss
'%s': %s must be a literal expression
static interfaces cannot have initializers
Initializer used on a global 'const' variable. This requires setting an external constant. If a literal is desired, use 'static const' instead.
'%s': missing %s
'%s' used but not defined
'%s': functions cannot be declared 'uniform'
'%s': functions cannot be declared 'extern'
'%s': interface methods cannot be static
'%s': function return value cannot contain Effects objects
'%s': method not found in class
'%s': interface methods cannot be declared outside of an interface
'%s': functions cannot have a target
'%s': methods cannot have a target or usage
'%s': void function cannot have a semantic
'%s': missing default value for parameter '%s'
'%s': return type does not match overridden method
%s cannot be redeclared
'%s' already defined as a %s
%s did not match any prototype in the class
'%s': function return value differs from prototype
'%s': 'static' mismatch between declaration and definition
'%s': default parameters can only be provided in the first prototype
'%s': interface methods cannot have bodies
invalid usage modifier applied to %cbuffer
vector dimension must be a literal scalar expression
vector dimension must be between 1 and %u
vector element type must be a scalar type
matrix dimensions must be literal scalar expressions
matrix dimensions must be between 1 and %u
matrix element type must be a scalar type
untyped textures are deprecated in strict mode
the 'sampler1D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'sampler2D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'sampler3D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'samplerCUBE' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'stateblock' keyword is deprecated in strict mode
non-numeric sample count
sample count must be non-zero
non-numeric vertex count
vertex count must be non-zero
matrix types cannot be both column_major and row_major
non-matrix types cannot be declared 'row_major' or 'column_major'
%cnorm can not be used with type
unsigned can not be used with type
object element type cannot be an object type
object's templated type must have at least one element
elements of typed buffers and textures cannot be arrays
elements of typed buffers and textures must fit in four 32-bit quantities
interfaces cannot inherit from other types
base type is not a struct, class or interface
multiple concrete base types specified
'%s': class does not implement method %s
array dimensions of type must be explicit
array dimensions must be literal scalar expressions
array dimension must be between 1 and 65536
secondary array dimensions must be explicit
interface arrays cannot be multi-dimensional
redefinition of type with struct/class
redefinition of type with interface
RWStructuredBuffer(Decrementable)
RWStructuredBuffer(Incrementable)
StateBlock
Texture2DArrayMS
<pointer>
<nocast>
<count>
<float32pp>
<error - out of memory>
<basic>
<compound>
<anonymous>
.$super
<error>*
typedef 
precise 
row_major 
column_major 
array_index 
<unknown qual> 
internal error: no storage type for block output
triangle_cw
triangle_ccw
integer
fractional_odd
fractional_even
isoline
the clip planes (up to 6) to use
c1, c2, c3, c4, c5, c6
clipplanes
earlydepthstencil
the maximum tessellation factor to allow
maxtessfactor
the number of control points to emit
outputcontrolpoints
one of "point", "line", "triangle_cw", or "triangle_ccw"
topology type
outputtopology
one of "integer", "pow2", "fractional_even", or "fractional_odd"
partitioning mode
partitioning
one of "tri", "quad", or "isoline"
domain type
the name of the patch constant value evaluation function
function name
patchconstantfunc
the dimensions of the thread group
numthreads
the number of instances of this shader to execute simultaneously
instance
MaxVertexCount
the maximum number of vertices emitted by this shader
maxvertexcount
'%s': input parameter '%s' missing semantics, expected %s
'%s': stream input parameter '%s' must be an inout parameter
'%s': stream input parameter '%s' can only be used in geometry shaders
'%s': input parameter '%s' cannot have a geometry specifier
'%s': interface input parameters not yet implemented for hull shaders, use a global interface instead
'%s': input parameter '%s' conflicts with geometry specifier of previous input parameters
'%s': may only have one InputPatch parameter
'%s': Patch constant function must use the same input control point type declared in the control point phase.
'%s': may only have one OutputPatch parameter
'%s': Patch constant function must use the same output control point type returned from the control point phase.
'%s': Patch constant function's output patch input should have %d elements, but has %d.
'%s': stream input parameter '%s' must be an inout parameter 
'%s': InputPatch inputs can only be used in hull and geometry (5_0+) shaders
'%s': OutputPatch inputs can only be used in the domain shaders and a hull shader's patch constant function
'%s': input parameter '%s' must have a geometry specifier
'%s': input parameter '%s' missing semantics
'%s': input parameter '%s' patch size must be in the range [1,32]
'%s': no input primitive specified, if your shader doesn't require inputs, then define an empty struct and give it the proper primitive type.
internal error: unrecognized geometry shader input primitive type
'%s': interfaces can only be inputs
'%s': %s only allows one depth output
'%s': function return value missing semantics
'%s': output parameter '%s' missing semantics
'%s': output parameters not yet implemented for control point shaders
'%s': Compute shaders can't return values, outputs must be written in writable resources (UAVs).
'%s': stream output parameter '%s' must be an inout parameter 
'%s': stream output parameter '%s' can only be used in geometry shaders
'%s': Geometry shaders can't return values, outputs must be written to streams.
'%s': Top-level return value is not completely initialized
'%s': output parameter '%s' not completely initialized
'%s': Top-level output parameter '%s' not completely initialized
'%s': top-level interface arguments cannot be 'out'
'%s' must have a max vertex count
'%s' must have a max vertex count greater then 0
%s does not allow instancing
GS instance count must be at least 1
%s only allows up to %u instances
the product of the arguments of %s(%u,%u,%u) must be at least %u
the product of the arguments of %s(%u,%u,%u) must be less than or equal to %u
the final dimension specified (%u) for %s must be less than or equal to %u
'%s': line output topologies are only available with isoline domains
'%s': triangle output topologies are not available with isoline domains
'%s' max tesselation factor must be in the range [1,64]
Clip plane attribute parameters must be non-literal constants
Indexed expressions are illegal as attribute parameters
'%s': recursive functions not allowed in %s
'%s': When defining a pass-through control-point shader,you must declare an InputPatch object.
'%s': When defining a pass-through control-point shader, the number of output control points must be zero or must match the input patch size.
'%s': Not all control paths return a value
internal error: unassociated return
'%s': global structs and classes cannot be changed
abstract interfaces not supported on %s
internal error: result register invalid
%s does not support doubles
%s does not support 8-bit or 16-bit integers
cannot use casts on l-values
cannot cast the LHS of an assignment to an indexable object, consider using asuint, asfloat, or asdouble on the RHS
in %s uints can only be used with known-positive values, use int if possible
internal error: l-value expected
internal error: inconsistent addressing
internal error: addressing inconsistent pool
internal error: inconsistent derivative writer
internal error: invalid sequence/cast expression
Bitwise operations not supported on legacy targets.
both sides of the && operator are always evaluated, side effect on '%s' will not be conditional
internal error: AND operator inputs not bool
both sides of the || operator are always evaluated, side effect on '%s' will not be conditional
internal error: OR operater inputs not bool
.mips can only be used in a two-element indexing expression such as .mips[mip][element]
.sample can only be used in a two-element indexing expression such as .sample[sample][element]
both sides of the ?: operator are always evaluated, side effect on '%s' will not be conditional
internal error: unrecognized expression
Derivatives of indexed variables are not yet implemented.
Output value '%s' is not completely initialized
multiply
firstbithigh
ddy_fine
ddy_coarse
ddx_fine
ddx_coarse
internal error: chain register invalid
integer divides may be much slower, try using uints if possible.
integer modulus may be much slower, try using uints if possible.
this operation cannot be used directly on resources containing doubles.
internal error: argument missing context <| A%u (B%u)
internal error: operand type mismatch
%s cannot be used with doubles, cast to float first
%s not supported on the given type
pdr_robj
input types for geometry shader must be arrays
array dimension for %s must be %i
GS Input
Patch semantics must live in the enclosed type, outer semantic ignored.
register %s not valid
textures
%s does not allow textures or samplers to be members of compound types
%s does not allow writable textures, samplers or UAVs to be members of compound types with interface inheritance
semantics in type overridden by variable/function or enclosing type
resources such as textures, samplers or UAVs cannot contain other resources
internal error: unknown node
SV_ClipDistance semantics cannot be used when using the clipplanes attribute
Duplicated input semantics can't change type, size, or layout ('%s').
globallycoherent can only be used with Unordered Access View buffers
globallycoherent cannot be used with append/consume buffers
typed UAV loads are only allowed for single-component 32-bit element types
Interface-reachable members containing UAVs or group shared variables are not yet implemented
inner array index within group shared element must be a literal expression for %s
race condition writing to shared resource detected, note that threads will be writing the same value, but performance may be diminished due to contention.
race condition writing to shared memory detected, note that threads will be writing the same value, but performance may be diminished due to contention.
race condition writing to shared resource detected, consider making this write conditional.
race condition writing to shared memory detected, consider making this write conditional.
array index out of bounds
array reference cannot be used as an l-value; not natively addressable
index for an array of complex types containing doubles must be a literal expression
%s array index must be a literal expression
Resource being indexed is uninitialized.
Resources being indexed cannot come from conditional expressions, they must come from literal expressions.
element type of texture too large. Cannot exceed 4 components
IncrementCounter/DecrementCounter are only valid on RWStructuredBuffer objects
Append/Consume not compatible with buffer type
case ordinal too large for floating point representation
can't flatten with flow control when variable is bound to b register
can't use flow control on this profile
can't emit if statement with both gradients and program flow control
internal error: flattened side effect
can't flatten if statements that contain out of bounds array accesses
can't force branch with gradients on non-inputs
can't flatten if statements that contain side effects
can't use branch and flatten attributes together
non-empty case statements must have break or return
error, duplicate default in switch statement
error, duplicate case %u
can't use branch, flatten, call  or case attributes together
Too many nested flow control constructs
Fall-throughs in switch statements are not allowed.
can't use call or forcecase attributes on switches in %s programs
flow control depth too deep to honor call or forcecase attribute
can't use loop and unroll attributes together
can't use fastopt and unroll attributes together
can't unroll loops marked with loop attribute
literal loop terminated early due to out of bounds array access
loop only executes for %d iteration(s), consider removing [loop]
loop only executes for %d iteration(s), forcing loop to unroll
cannot map loop to shader target, target does not support breaks
can't use gradient instructions in loops with break
loop executes for more than %d iterations (maximum for this shader target), forcing loop to unroll
loop doesn't seem to do anything, consider removing [loop]
loop doesn't seem to do anything, forcing loop to unroll
infinite loop detected - loop writes no values
loop will not exit early, try to make sure the loop condition as tight as possible
automatic unrolling has been disabled for this loop, consider using [unroll] or manual unrolling
loop termination conditions in varying flow control cannot depend on data read from a UAV
infinite loop detected - loop never exits
gradient instruction used in a loop with varying iteration, forcing loop to unroll
texture access must have literal offset and multisample index
synchronization operations cannot be used in varying flow control
loop simulation finished early, use /O1 or above for potentially better codegen
cannot unroll loop with an out-of-bounds array reference in the condition
forced to unroll loop, but unrolling failed.
unable to unroll loop, loop does not appear to terminate in a timely manner (%d iterations)
unable to unroll loop, loop does not appear to terminate in a timely manner (%d iterations), use the [unroll(n)] attribute to force an exact higher number
break must be inside loop
continue must be inside loop
Consume
IncrementCounter
DecrementCounter
byteOffset
GetSamplePosition
samples
GatherRed
GatherGreen
GatherCmpRed
GatherCmpGreen
GatherCmpBlue
GatherCmpAlpha
GatherCmp
GatherBlue
GatherAlpha
elements
SampleLevel
SampleGrad
SampleCmpLevelZero
SampleCmp
SampleBias
GetDimensions
CalculateLevelOfDetailUnclamped
CalculateLevelOfDetail
RestartStrip
transpose
texCUBEproj
texCUBElod
texCUBEgrad
texCUBEbias
texCUBE
tex3Dproj
tex3Dlod
tex3Dgrad
tex3Dbias
tex2Dproj
tex2Dlod
tex2Dgrad
tex2Dbias
tex1Dproj
tex1Dlod
tex1Dgrad
tex1Dbias
smoothstep
saturate
reversebits
refract
reflect
radians
normalize
isfinite
firstbitlow
faceforward
f32tof16
f16tof32
distance
determinant
degrees
countbits
asfloat
asdouble
__test_intrin4
__test_intrin3
__test_intrin2
__test_intrin1
ProcessTriTessFactorsMin
ProcessTriTessFactorsMax
UnroundedInsideFactor
RoundedInsideFactor
ProcessTriTessFactorsAvg
ProcessQuadTessFactorsMin
ProcessQuadTessFactorsMax
ProcessQuadTessFactorsAvg
RoundedDensityFactor
RoundedDetailFactorr
RawDensityFactor
RawDetailFactor
ProcessIsolineTessFactors
Process2DQuadTessFactorsMin
Process2DQuadTessFactorsMax
UnroundedInsideFactors
RoundedInsideFactors
RoundedEdgeFactors
InsideScale
RawEdgeFactors
Process2DQuadTessFactorsAvg
InterlockedXor
InterlockedOr
InterlockedMin
InterlockedMax
InterlockedExchange
InterlockedCompareStore
compare
InterlockedCompareExchange
InterlockedAnd
original
InterlockedAdd
GroupMemoryBarrierWithGroupSync
GroupMemoryBarrier
GetRenderTargetSamplePosition
GetRenderTargetSampleCount
EvaluateAttributeSnapped
EvaluateAttributeCentroid
EvaluateAttributeAtSample
DeviceMemoryBarrierWithGroupSync
DeviceMemoryBarrier
D3DCOLORtoUBYTE4
AllMemoryBarrierWithGroupSync
AllMemoryBarrier
gradient operation uses a value that may not be defined for all pixels (in %s UAV loads can not participate in gradient operations)
%s does not support aborts
%s does not support messages
abs on unsigned values is not meaningful, ignoring
value cannot be infinity, isfinite() may not be necessary.  /Gis may force isfinite() to be performed
value cannot be infinity, isinf() may not be necessary.  /Gis may force isinf() to be performed
value cannot be NaN, isnan() may not be necessary.  /Gis may force isnan() to be performed
asfloat can only be used on floating point values on %s
asint cannot be used on %s
asuint cannot be used on %s
asdouble can only be used on uint values on %s
asuint can only be used on double values on %s
Sampler parameter must come from a literal expression.
tex1D will be considered dependent since texcoord was not declared as at least float2
intrinsic function '%s' is not yet implemented
return type of texture too large. Cannot exceed 4 components
pow(f, e) will not work for negative f, use abs(f) or conditionally handle negative values if you expect them
Tessellation factor scale will be clamped to the range [0, 1]
Tess factor processing functions only available on shader model 4+
Globals
Interface
State Block
Annotation
internal error: failed generating debug info
integer literal %u64 too large, truncated
internal error: this-relative %s '%s' found outsideof function scope
static method %s cannot refer to instance members
undeclared identifier '%s'
data member
'%s': initializer does not match type
object literals are not allowed inside functions
global variables are implicitly constant, enable compatibility mode to allow modification
global variables are implicitly constant, variables of classes with interface inheritance can never be modified
l-value specifies const object
int or unsigned int type required
scalar, vector, or matrix expected
operator cannot be used with a bool lvalue
couldn't cast expression to integer
unary negate of unsigned value is still unsigned
couldn't cast expression to boolean for logical not operator
type mismatch
signed/unsigned mismatch, unsigned assumed
couldn't cast expression to boolean for logical operator
comma expression used where an initializer list may have been intended
comma expression used where a vector constructor may have been intended
constructors only defined for numeric base types
cannot convert from 'object type' to 'numeric type'
incorrect number of arguments to numeric-type constructor
conditional must be numeric
type mismatch between conditional values
dimension of conditional does not match value
array, matrix, vector, or indexable object type expected in index expression
invalid type for index - index must be a scalar, or a vector with the correct number of dimensions
Sub index list
Swizzle
invalid subscript '%s'
Partials
Outputs
out parameters require l-value arguments (given argument is implicitly const, such as a global)
out parameters require l-value arguments
'%s': %ss are limited to no more than %u parameters (%u given)
'%s': %s does not take %u parameter%s
Possible %ss are:
Parameters
Method and Parameters
intrinsic function
%s does not have method '%s'
'%s': static methods cannot be called on objects
%s object does not have methods
%s object does not have method '%s'
intrinsic method
'%s': void functions cannot return a value
'%s': function must return a value
potentially unintended use of a comma expression in a return statement
if statement conditional expressions must evaluate to a scalar
could not cast condition to boolean
scalar value expected
could not cast condition to uint
non-scalar case expression
non-numeric case expression
CaseStmts
'%s': loop control variable conflicts with a previous declaration in the outer scope; most recent declaration will be used
internal error: unable to add non-conflicting symbol
function '%s' missing implementation
flow control depth too deep to emit function call
late-resolve interface calls nested too deeply
interface references must resolve to non-varying objects
internal error: failed to devirtualize a contained interface call
no classes implement '%s'
SetRenderTargets
SetDepthStencilState
SetBlendState
SetRasterizerState
SetVertexShader
SetPixelShader
SetGeometryShader
D3D10_SHADER_DEBUG
D3D10_SHADER_SKIP_OPTIMIZATION
D3D10_SHADER_PARTIAL_PRECISION
D3D10_SHADER_NO_PRESHADER
D3D10_SHADER_AVOID_FLOW_CONTROL
D3D10_SHADER_PREFER_FLOW_CONTROL
D3D10_SHADER_ENABLE_BACKWARDS_COMPATIBILITY
D3D10_SHADER_IEEE_STRICTNESS
invalid compiler flag %s
parameter count mismatch (%s)
this FX API is not available in this part your program (%s)
Unrecognized FX function call (%s)
DX9-style 'LHS = <RHS>' syntax is deprecated in strict mode
unsupported compiler target '%s'
the debug info flag can only be set globally
%s shader fragments are not supported
DX9-style 'compile' syntax is deprecated in strict mode
DX9-style '= sampler_state' syntax is deprecated in strict mode
internal error: not all rules initialized
internal error: Rule class id invalid
$Params
$ThisPointer
[internal error]
Zero character semantics aren't allowed
SV_PrimitiveId
SV_InstanceId
cannot bind the same variable to multiple constants in the same constant bank
<unknown shader model>
reduce literal lit instruction <| Explicit
symmetric cmp <| Explicit
reduce mov instruction <| Explicit
min of known positive identity <| Explicit
max of known positive identity <| Explicit
lt of known range reduction <| Explicit
ge of known range reduction <| Explicit
atan of known 0 or 1 identity <| Explicit
mul of a half times add of same value identity <| Explicit
negative bool less then another bool identity <| Explicit
bool multiply chain reduction <| Explicit
dot of partial nullity reduction <| Explicit
eval mul <| Explicit
min(x,y) where range of one is <= the other (ieee safe version) <| Explicit
max(x,y) where range of one is >= the other (ieee safe version) <| Explicit
cmp of negated bool identity <| Explicit
cmp diff to basic logic identity <| Explicit
Negative values for cmp and clip can be rordered <| Explicit
Negative value compared with zero <| Explicit
Sequence of compares <| Explicit
FRC of add with integer can bypass add <| Explicit
Mulitply by 1 reduces to no-op move <| Explicit
Multiply by -1 reduces to NEG operation <| Explicit
integer add sequence simplification <| Explicit
integer multiply by one identity <| Explicit
integer multiply by zero identity <| Explicit
integer multiply by negative one identity <| Explicit
integer multiply by literal identity <| Explicit
shift of commutative literals <| Explicit
combine of commutative literals <| Explicit
shift of commutative inputs <| Explicit
imin(x,y) where one is <= the other <| Explicit
imax(x,y) where one is >= the other <| Explicit
umin(x,y) where one is <= the other <| Explicit
umax(x,y) where one is >= the other <| Explicit
umod(x,y) where x < y <| Explicit
Eval range add inf flag if range not bound <| Explicit
Eval range add NaN flag if integer mask says it's possible <| Explicit
propagate range info through mov <| Explicit
propagate special floating point values through div <| Explicit
propagate special floating point values through log <| Explicit
propagate special floating point values through mul <| Explicit
propagate special floating point values through rsq <| Explicit
propagate special floating point values through rcp <| Explicit
propagate special floating point values through sqrt <| Explicit
propagate special floating point values through asin <| Explicit
propagate special floating point values through atan2 <| Explicit
(A + L2) - (A + L1) = L2 - L1 if A non-NaN/Inf <| Explicit
Don't truncate double values to floats <| Explicit
Don't flush denorm values to zero <| Explicit
Literal in Log * Mul * Exp pattern <| Explicit
Addition of same argument is same as multiply by 2 <| Explicit
Multiply by 2, 4, or 8 <| Explicit
Multiply by 0 reduces to literal 0 <| Explicit
A * (1/A) = 1 <| Explicit
range sequence reduction <| Explicit
Known literals reduced to mov <| Explicit
rsq result can be assumed positive <| Explicit
min(x,y) where range of one is <= the other <| Explicit
max(x,y) where range of one is >= the other <| Explicit
Simplify conditions on instructions which only care about sign on possibly NaN/Inf values <| Explicit
Simplify cmp sequences on possibly NaN/Inf values <| Explicit
Simplify pow on possibly NaN/Inf values <| Explicit
Simplify fractional add on possibly NaN/Inf values <| Explicit
CombineInstructions can create dots <| Explicit
vectorize tunnel through mul <| Explicit
vectorize tunnel through neg <| Explicit
vectorize tunnel through add <| Explicit
Change swizzle of parameters to dot <| Explicit
negate modifier match <| Explicit
sat instruction to sat modifier match <| Explicit
abs instruction to abs modifier match <| Explicit
integer negate modifier match <| Explicit
max of neg idenity to abs instruction match <| Explicit
Don't use marker values for clamped literal conversions <| Explicit
propogate swizzles <| Explicit
attempt to group scalar values read by similar instructions <| Explicit
Emit return instructions <| Explicit
Emit output arrays <| Explicit
Tunnel through temp arrays on load <| Explicit
initialize arrays to void <| Explicit
emit write masks on sample instructions <| Explicit
reorder instructions to minimize register load <| Explicit
Use replicate swizzles to squish literal arrays <| Explicit
Try swizzling literal arrays to fit them together <| Explicit
Try to match temp array loads to their original store <| Explicit
Remove temp array stores that are immediately overwritten <| Explicit
Try to reduce known values to movs <| Explicit
Try to combine like instructions <| Explicit
Remove args for CBuffers that are never read <| Explicit
Hoist predicated code into outermost predicate <| Explicit
search for instancing opportunities in hull shaders <| Explicit
enable instancing searches for programs with multiple outputs <| Explicit
combine simple instructions to reduce instruction count <| Explicit
Compact Registers - Paint  <| Explicit
Compact Registers - Press Moves <| Explicit
Compact Registers - Press Loop Ins <| Explicit
Compact Registers - Compress <| Explicit
mov of sampler register reduction <| Explicit
detect errors induced by race conditions <| Explicit
if(x){} else {...} -> if(!x) {...} <| Explicit
if(x){...} else {} -> if(x) {...} <| Explicit
if(x){...} if(x){...} -> if(x) {... ...} <| Explicit
movc(c,ignore,a) -> mov(a) <| MR.GenSimplifyInstructionsAlways_Both
movc(c,a,ignore) -> mov(a) <| MR.GenSimplifyInstructionsAlways_Both
movc(c,ignore,ignore) -> ignore(0) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(c,ignore,a) -> dmov(a) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(c,a,ignore) -> dmov(a) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(c,ignore,ignore) -> ignore(0) <| MR.GenSimplifyInstructionsAlways_Both
break never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
continue never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
return never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
NOT BLT => BGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BGE => BLT <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BLT => BGE (safe) <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BGE => BLT (safe) <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BEQ => BNE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BNE => BEQ <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BILT => BIGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BIGE => BILT <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BIEQ => BINE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BINE => BIEQ <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BULT => BUGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BUGE => BULT <| MR.GenSimplifyInstructionsOpt1_Excl
a*(1/(b*a)) -> 1 / b <| MR.GenSimplifyInstructionsOpt1_Excl
combine AND of two equal unknown left shifts <| MR.GenSimplifyInstructionsOpt1_Excl
combine AND of two equal unknown right shifts <| MR.GenSimplifyInstructionsOpt1_Excl
combine AND of two equal unknown unsigned right shifts <| MR.GenSimplifyInstructionsOpt1_Excl
back-propagate negate through iadd <| MR.GenSimplifyInstructionsOpt1_Excl
back-propagate negate through imul <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(ishl(a, b), c) : if( nooverflow_mod_32(b, c) ) -> ishl(a, iadd(b, c)) <| MR.GenSimplifyInstructionsOpt1_Excl
ushr(ishl(a, bv), cv) : if( ge_mod_32(cv, bv) ) -> and(ushr(a, cv - bv), (1 << (32-cv))-1) <| MR.GenSimplifyInstructionsOpt1_Excl
ishr(ishr(a, b), c) : if( nooverflow_mod_32(b, c) ) -> ishr(a, iadd(b, c)) <| MR.GenSimplifyInstructionsOpt1_Excl
(a & b) | (a & c) -> and(a, b | c) <| MR.GenSimplifyInstructionsOpt1_Excl
b | (a & c) | (a & d) -> or(b, and(a, or(c,d)) <| MR.GenSimplifyInstructionsOpt1_Excl
and(or(a, iv1), iv2) -> or(and(a, iv2), and(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
or(and(a, iv1), iv2) if(and_ne_zero(iv1, iv2) -> or(and(a, iv1 & ~iv2), iv2) <| MR.GenSimplifyInstructionsOpt1_Excl
u/ishr/l(or(a, iv1), iv2) -> or(u/ishr/l(a, iv2), u/ishr/l(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
u/ishr/l(and(a, iv1), iv2) -> and(u/ishr/l(a, iv2), u/ishr/l(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
u/ishr/l(xor(a, iv1), iv2) -> xor(u/ishr/l(a, iv2), u/ishr/l(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(imul(a, iv1), iv2) : if(low_bit_clear(iv2)) -> imul(ishl(a, iv2/2), ishl(iv1, iv2/2)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(ineg(a), iv1) -> ineg(ishl(a, iv1)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(iadd(a, iv1), iv2) -> iadd(ishl(a, iv2), ishl(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
ushr(ushr(a, b), c) : if( nooverflow_mod_32(b, c) ) -> ushr(a, iadd(b, c)) <| MR.GenSimplifyInstructionsOpt1_Excl
split literal sum ishl to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
split literal sum ishr to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
split literal sum ushr to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
a = bfi(w, o, v, 0i) | r : if( mask_is_zero(w,o,r) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_Excl
r | (a = bfi(w, o, v, 0i)) : if( mask_is_zero(w,o,r) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_Excl
bfi(w, o, v, n) << s -> bfi(w, o+s, v, n) <| MR.GenSimplifyInstructionsOpt1_Excl
ubfe(w, o, a) >> s -> ubfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_Excl
ubfe(w, o, (a >> s) & m) : if( o + s < 32 ) -> ubfe(w, o + s, a & (m << s)) <| MR.GenSimplifyInstructionsOpt1_Excl
ibfe(w, o, (a >> s) & m) : if( o + s < 32 ) -> ibfe(w, o + s, a & (m << s)) <| MR.GenSimplifyInstructionsOpt1_Excl
ibfe(w, o, ((uint)a >> s) & m) : if( w + o + s < 32 ) -> ibfe(w, o + s, a & (m << s)) <| MR.GenSimplifyInstructionsOpt1_Excl
-sin(x) -> sin(-x) <| MR.GenSimplifyInstructionsOpt1_Excl
-dtof(x) -> dtof(-x) <| MR.GenSimplifyInstructionsOpt1_Excl
-ftod(x) -> ftod(-x) <| MR.GenSimplifyInstructionsOpt1_Excl
bfi(w, 0i, n, n) -> mov(n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, o, v, bfi(w, o, 0, n)) -> bfi(w, o, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, o, v, n) << s -> bfi(w, o+s, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, 0, v, n << w) : if( w != 0 ) -> bfi(32-w, w, n, v) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(bfi(w, o, 0, n) | bfi(w, o, v, 0)) -> bfi(w, o, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(bfi(w, 0i, 0, n) | ubfe(w, 0i, v)) -> bfi(w, 0i, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, 0i, a) << o -> bfi(w, o, a, 0i) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, 0i, a, 0i) -> ubfe(w, 0i, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, 0i, a >> s) -> ubfe(w, s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, o, a >> s) : if( o + s < 32 ) -> ubfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe(w, o, a >> s) : if( o + s < 32 ) -> ibfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe(w, o, (uint)a >> s) : if( o + s + w < 32 ) -> ibfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, o, a) >> s : if( o + s < 32 && w >= s ) -> ubfe(w - s, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe(w, o, a) >> s : if( o + s < 32 && w >= s ) -> ibfe(w - s, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
b = ubfe(w, o, a); movc(b & (1 << (w - 1 + o)), b | ~((1 << w + o)-1), b) -> ibfe(w, o, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, v, 0i) | r : if( mask_is_zero(w,o,r) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, v, and(m, r)) : if( unmasked_is_one_or_val_is_zero(w,o,v,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, v, and(r, m)) : if( unmasked_is_one_or_val_is_zero(w,o,v,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, and(v, m), r) : if( masked_is_one(w,o,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, and(m, v), r) : if( masked_is_one(w,o,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(and(w,31), o, v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(and(31,w), o, v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, and(o,31), v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, and(31,o), v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
abs(a), a positive -> a <| MR.GenSimplifyInstructionsOpt1_NoExcl
abs(a), a negative -> neg(a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
frc(a + int) = frc(a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsRound(fp int) = mov(fp int) <| MR.GenSimplifyInstructionsOpt1_NoExcl
add of zero identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
double add of zero identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
add of negative of itself identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (!A + A) => 1 + B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy !A + (A + B) => 1 + B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy C + (A * B) + (A * !B) => C + A <| MR.GenSimplifyInstructionsOpt1_NoExcl
LERP(!A,B,C) -> LERP(A, C, B) <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval eq <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval bne on non-nan value <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval ge <| MR.GenSimplifyInstructionsOpt1_NoExcl
binary expression with negative symmetry reduction <| MR.GenSimplifyInstructionsOpt1_NoExcl
bge(mul(x,x),neg(mul(x,x))) -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
IGE a,a -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
ILT a,a -> false <| MR.GenSimplifyInstructionsOpt1_NoExcl
bine(ishl(a, n),0) : if(upper_n_bits_are_zero(a, n)) -> bine (a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bine(i/ushr(a, n),0) : if(lower_n_bits_are_zero(a, n)) -> bine (a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dtof(ftod(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a != b) ? a : b -> a <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a != b) ? b : a -> b <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == b) ? a : b -> b <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == b) ? b : a -> a <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == (b ? c : a)) : if (c != a) -> b == 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == (b ? a : c)) : if (c != a) -> b != 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
firstbit*(x) != -1 -> x != 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
firstbit*(x) == -1 -> x == 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
x ? firstbit*(x) : -1 -> firstbit*(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsAnyShift(x, and(y, 31)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsAnyShift(x, and(31, y)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(ishl(a, n),v1, v2) : if(upper_n_bits_are_zero(a, n)) -> movc (a, v1, v2) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(i/ushr(a, n),v1, v2) : if(lower_n_bits_are_zero(a, n)) -> movc (a, v1, v2) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, i/ushr/l(a, n), 0) -> i/ushr/l(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, b, i/ushr/l(a, n)) -> movc(a, b, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(u/ishr/l(a, n), movc(a, b, c), d) -> movc(u/ishr/l(a, n), b, d) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A+A REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A+A <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2>0) REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2>0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2<0) REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2<0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A+A REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A+A (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2>0) REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2>0) (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2<0) REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2<0) (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 divides L as a UINT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 divides L as a UINT <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 > 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 > 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 < 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 < 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval lt <| MR.GenSimplifyInstructionsOpt1_NoExcl
btof -> movc <| MR.GenSimplifyInstructionsOpt1_NoExcl
btoi -> movc <| MR.GenSimplifyInstructionsOpt1_NoExcl
UGE a,a -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
ULT a,a -> false <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input via mov right <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input via mov left <| MR.GenSimplifyInstructionsOpt1_NoExcl
clip(a+a,b) -> clip(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
clip(+d * a,b) -> clip(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
nullify clip ops on known positive values <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove clips that are merged with known-success clips <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove clip chains that are merged with known-success clips <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(+d * a,b,c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-d * a,b,c) -> cmp(-a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-b,0,b) -> cmp(b,b,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp of known positive identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp of known negative identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(a+a,b,c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
symmetric cmp <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(cmp(a, >=0, <0), b, c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(cmp(a, <0, >=0), b, c) -> cmp(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-cmp(a, <=0, >0), b, c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-cmp(a, >0, <=0), b, c) -> cmp(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT (A || A) => NOT A <| MR.GenSimplifyInstructionsOpt1_NoExcl
CMP(c,d=1+CMP(c,a,b),f) -> CMP(c,1+a,f) <| MR.GenSimplifyInstructionsOpt1_NoExcl
nullify discard ops on known false values <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove discards that are merged with known-success discards <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove discard chains that are merged with known-success discards <| MR.GenSimplifyInstructionsOpt1_NoExcl
division by a literal becomes multiplication by reciprocal <| MR.GenSimplifyInstructionsOpt1_NoExcl
1 / x -> rcp(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dot(normalized_v, normalized_v) == 1.0 when v has length <| MR.GenSimplifyInstructionsOpt1_NoExcl
exp(log(x)) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftob(trunc(btof(x))) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftoi(itof(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftoi(trunc(itof(x))) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftou(utof(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftou(trunc(utof(x))) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT GE => LT <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT LT => GE <| MR.GenSimplifyInstructionsOpt1_NoExcl
iadd zero reduces to no-op mov <| MR.GenSimplifyInstructionsOpt1_NoExcl
Integer addition negative identities <| MR.GenSimplifyInstructionsOpt1_NoExcl
iadd(a, b) : if( and_is_zero(a, b) ) -> or(a, b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
if(bine(x,0)) -> if(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imul one reduces to no-op mov <| MR.GenSimplifyInstructionsOpt1_NoExcl
ineg(and(ne(x,0),1)) -> ne(x,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ineg(ineg(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishl/r(a, 0) -> mov(a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
((a >> ov1) << o2) : if( ov1 == o2 ) -> and(a, ~((1 << ov1)-1)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(or(a, m), n) : if( or_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(or(m, a), n) : if( or_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(and(a, m), n) : if( and_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(and(m, a), n) : if( and_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(or(a, m), n) : if( or_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(or(m, a), n) : if( or_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(and(a, m), n) : if( and_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(and(m, a), n) : if( and_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imul(ishl(iv1, a), iv2) -> ishl(imul(iv1, iv2), a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A + B for boolean A & B -> OR A, B <| MR.GenSimplifyInstructionsOpt1_NoExcl
A * B for boolean A & B -> AND A, B <| MR.GenSimplifyInstructionsOpt1_NoExcl
itob(x) -> bine(x,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
itof(ftoi(x)) -> trunc(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
log(exp(x)) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
exp(a*log(0)) = 0 identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy -BOOL < BOOL => BOOL <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (A || A) => A <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(max(i0, l1), l2) -> max(i0, max(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(dmax(i0, l1), l2) -> dmax(i0, dmax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(imax(i0, l1), l2) -> imax(i0, imax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(umax(i0, l1), l2) -> umax(i0, umax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(min(i0, l1), l2) -> min(i0, min(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin(dmin(i0, l1), l2) -> dmin(i0, dmin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(imin(i0, l1), l2) -> imin(i0, imin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(umin(i0, l1), l2) -> umin(i0, umin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a,true,false) -> bine(a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a,false,true) -> bieq(a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(true,b,c) -> mov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(false,b,c) -> mov(c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(true,b,c) -> dmov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(false,b,c) -> dmov(c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, true, b) -> or(a, b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc and comparison sequence reductions <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, b, movc(c, b, d)) -> movc(or(a, c), b, d) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, b, and(c, b)) -> and(or(a, c), b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, and(b, c), 0) -> and(and(a, b), c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(!a,b,c) -> movc(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(!a,b,c) -> dmovc(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(movc(a,TRUE,FALSE),b,c) -> movc(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(movc(a,FALSE,TRUE),b,c) -> movc(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, TRUE, FALSE) -> mov b <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, FALSE, TRUE) -> not b <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, TRUE, bool c) -> or(b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, bool b, false) -> mov b <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(b, a, b) -> movc (b, a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : umin(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
bool ? a + 1 : a -> a - bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
bool ? a - 1 : a -> a + bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : imin(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : min(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : dmin(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> min(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> min(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> min(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> dmin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> dmin(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> dmin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(0 < n) ? 1 : 0 -> umin(1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> umin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> umin(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> umin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> imin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> imin(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> imin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a,b,b) -> mov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(a,b,b) -> dmov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((a<b),a,b) -> min(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer movc((a<b),a,b) -> min(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned integer movc((a<b),a,b) -> min(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((a<b),a,b) -> dmin(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((a<b),b,a) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer movc((a<b),b,a) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned integer movc((a<b),b,a) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((a<b),b,a) -> dmax(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((a>=b),a,b) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer movc((a>=b),a,b) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned integer movc((a>=b),a,b) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((a>=b),a,b) -> dmax(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((a>=b),b,a) -> min(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer movc((a>=b),b,a) -> min(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned integer movc((a>=b),b,a) -> min(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((a>=b),b,a) -> dmin(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(c,d=movc(c,a,b),f) -> movc(c,a,f) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(c,f,d=movc(c,a,b)) -> movc(c,f,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(c,d=cmp(c,a,b),f) -> cmp(c,a,f) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(c,f,d=cmp(c,a,b)) -> cmp(c,f,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul of one identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul of double one identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
(A + A) * 0.5 -> no-op mov of A <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul of a number times its inverse identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
A * B/A with negative variations on A <| MR.GenSimplifyInstructionsOpt1_NoExcl
normalize(normalize(v)) -> normalize(v) <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy !A * (A + B) => !A * B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy A * !(A * B) => A * !B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (!A * A) => 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
B*!(A * -B + B) -> A * B <| MR.GenSimplifyInstructionsOpt1_NoExcl
double negative to original <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(ine(x,0),ine(y,0)) -> ine(or(x,y),0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
combine OR of two equal shifts <| MR.GenSimplifyInstructionsOpt1_NoExcl
combine XOR of two equal shifts <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND ~X => 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND Y : if( and_is_identity(x,y) => X <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND Y : if( and_is_identity(y,x) => Y <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(and(a, b), c) : if( and_is_identity(c, b) ) -> and(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(and(b, a), c) : if( and_is_identity(c, b) ) -> and(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(a, iv2) : if( can_reduce_and(a, iv2) ) -> and(a, get_reduced_and(a, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR ~X => btrue <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR Y : if( or_is_identity(x,y) => X <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR Y : if( or_is_identity(y,x) => Y <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(a, iv2) : if( can_reduce_or(a, iv2) ) -> or(a, get_reduced_or(a, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(or(a, b), c) : if( or_is_identity(c, b) ) -> or(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(or(b, a), c) : if( or_is_identity(c, b) ) -> or(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
double rcp identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
rcp(mul(x, rsq(x)) = rsq(x) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
rsq(x) * rsq(x) -> rcp(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
rsq(x) * rsq(x) -> rcp(x) for positive x <| MR.GenSimplifyInstructionsOpt1_NoExcl
1 / sqrt(x) -> rsq(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
sqrt times sqrt of positive value equals the original value identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
positive sqrt(x*x) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
convert mod by power-of-2 to bitwise AND <| MR.GenSimplifyInstructionsOpt1_NoExcl
utof(sampleinfo_uint(x)) -> sampleinfo(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
xor(xor(a, iv1), iv2) -> xor(a, xor(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
replace bitwise double-complement with move <| MR.GenSimplifyInstructionsOpt1_NoExcl
bine(b,0) -> b <| MR.GenSimplifyInstructionsOpt2_NoExcl
movc(bool,x,0) -> and(bool,x) <| MR.GenSimplifyInstructionsOpt2_NoExcl
utof(sampleinfo_uint_rt(x)) -> sampleinfo_rt(x) <| MR.GenSimplifyInstructionsSampleMask_Both
movc, unary_compute on values lhs -> unary_compute, movc <| MR.GenShuffleCompute_Excl
movc, unary_compute on values rhs -> unary_compute, movc <| MR.GenShuffleCompute_Excl
cmp, unary_compute on values lhs -> unary_compute, cmp <| MR.GenShuffleCompute_Excl
cmp, unary_compute on values rhs -> unary_compute, cmp <| MR.GenShuffleCompute_Excl
movc, binary_compute on values lhs -> binary_compute, movc <| MR.GenShuffleCompute_Excl
movc, binary_compute on values rhs -> binary_compute, movc <| MR.GenShuffleCompute_Excl
cmp, binary_compute on values lhs -> binary_compute, cmp <| MR.GenShuffleCompute_Excl
cmp, binary_compute on values rhs -> binary_compute, cmp <| MR.GenShuffleCompute_Excl
movc, ternary arg1 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg1 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg2 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg2 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg3 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg3 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, quat arg1 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg1 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg2 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg2 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg3 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg3 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg4 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg4 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, unary_compute on values -> unary_compute, movc <| MR.GenShuffleCompute_NoExcl
cmp, unary_compute on values -> unary_compute, cmp <| MR.GenShuffleCompute_NoExcl
and, unary_compute on values -> unary_compute, and <| MR.GenShuffleCompute_NoExcl
movc, binary_compute on values -> binary_compute, movc <| MR.GenShuffleCompute_NoExcl
movc, binary_compute on same value -> binary_compute, movc <| MR.GenShuffleCompute_NoExcl
cmp, binary_compute on values -> binary_compute, cmp <| MR.GenShuffleCompute_NoExcl
cmp, binary_compute on same value -> binary_compute, cmp <| MR.GenShuffleCompute_NoExcl
and, binary_compute on values -> binary_compute, and <| MR.GenShuffleCompute_NoExcl
movc, ternary arg1 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, ternary arg2 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, ternary arg3 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg1 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg2 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg3 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg1 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg2 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg3 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg4 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg1 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg2 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg3 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg4 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
mad match 1 (a + b*c) <| MR.GenMad
mad match 2 (a - b*c) <| MR.GenMad
mad match 3 (a + b+b) <| MR.GenMad
mad match 4 (a - b+b) <| MR.GenMad
imad match 1 (a + b*c) <| MR.GenMad
imad match 2 (a + b+b) <| MR.GenMad
a << L | b (bfi(w=32-L, o=L, a, b) if( mask_is_zero(w, o, b) && allbutwidth_is_zero(w, a) -> imad (a, 1 << L, B) <| MR.GenMad
if+lt -> if_lt <| MR.Gen_PreModTarget_Both
if+ge -> if_ge <| MR.Gen_PreModTarget_Both
if+cmp_lt -> if_lt <| MR.Gen_PreModTarget_Both
if+cmp_ge -> if_ge <| MR.Gen_PreModTarget_Both
if+cmp_lt0 -> if_lt0 <| MR.Gen_PreModTarget_Both
if+cmp_ge0 -> if_ge0 <| MR.Gen_PreModTarget_Both
if_lt(neg(abs(x)), 0) -> if_ne0 <| MR.Gen_PreModTarget_Both
if_ge(neg(abs(x)), 0) -> if_eq0 <| MR.Gen_PreModTarget_Both
if_lt(-a^2,a^2) -> if_ne(a,0) <| MR.Gen_PreModTarget_Both
if_ge(-a^2,a^2) -> if_eq(a,0) <| MR.Gen_PreModTarget_Both
if_ne(x, 0) -> if_ne(x, -x) <| MR.Gen_PreModTarget_Both
if_ge(x + y, 0) -> if_ge(x, -y) <| MR.Gen_PreModTarget_Both
if_lt(x + y, 0) -> if_lt(x, -y) <| MR.Gen_PreModTarget_Both
if_ne(x + y, 0) -> if_ne(x, -y) <| MR.Gen_PreModTarget_Both
if_eq(x + y, 0) -> if_eq(x, -y) <| MR.Gen_PreModTarget_Both
break(a,not(x)) -> breakn(a,x) <| MR.Gen_PreModTarget_Both
continue(a,not(x)) -> continuen(a,x) <| MR.Gen_PreModTarget_Both
return(a,not(x)) -> returnn(a,x) <| MR.Gen_PreModTarget_Both
break(a,bieq(x,0)) -> breakn(a,x) <| MR.Gen_PreModTarget_Both
continue(a,bieq(x,0)) -> continuen(a,x) <| MR.Gen_PreModTarget_Both
return(a,bieq(x,0)) -> returnn(a,x) <| MR.Gen_PreModTarget_Both
break(a,bine(x)) -> break(a,x) <| MR.Gen_PreModTarget_Both
continue(a,bine(x)) -> continue(a,x) <| MR.Gen_PreModTarget_Both
return(a,bine(x)) -> return(a,x) <| MR.Gen_PreModTarget_Both
break(ge(neg(fbool), fbool)) -> break_eq(fbool, 0) <| MR.Gen_PreModTarget_Both
BREAK_GE i2,i1 short form <| MR.Gen_PreModTarget_Both
BREAK_GE i2,i1 for targets that use CMP <| MR.Gen_PreModTarget_Both
BREAK_GE i2,-iv1 where iv1 is literal and needs to be negated before using <| MR.Gen_PreModTarget_Both
BREAK_LT i2,i1 short form <| MR.Gen_PreModTarget_Both
BREAK_LT i2,i1 for targets that use CMP <| MR.Gen_PreModTarget_Both
BREAK_LT i2,-iv1 where iv1 is literal and needs to be negated before using <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,i1 <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,i1 matches when CMP is used <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,-iv1 where iv1 is literal and has to be negated <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,-iv1 where iv1 is literal and has to be negated, CMP form <| MR.Gen_PreModTarget_Both
BREAK_NE i2,i1 <| MR.Gen_PreModTarget_Both
BREAK_NE i2,i1 with CMP <| MR.Gen_PreModTarget_Both
BREAK_NE i2,-iv1 where iv1 is literal and has to be negated <| MR.Gen_PreModTarget_Both
BREAK_NE i2,-iv1 where iv1 is literal and has to be negated, CMP form <| MR.Gen_PreModTarget_Both
movc(blt(a, 0), |a|, a) -> abs(a) <| MR.GenD3D10PreMod_NoExcl
dmovc(bdlt(a, 0), |a|, a) -> dabs(a) <| MR.GenD3D10PreMod_NoExcl
breaka match <| MR.GenD3D10PostMod_Both
continuea match <| MR.GenD3D10PostMod_Both
returna match <| MR.GenD3D10PostMod_Both
if(bult(0,x)) -> if(x) <| MR.GenD3D10PostMod_Both
if(bilt(0,x)) -> if(x) <| MR.GenD3D10PostMod_Both
if(bieq(x,0)) -> ifn(x) <| MR.GenD3D10PostMod_Both
if(bine(x,0)) -> if(x) <| MR.GenD3D10PostMod_Both
if(!a) -> ifn(a) <| MR.GenD3D10PostMod_Both
bfi(w, 0i, v, r) : if( width_is_zero(w,r) && allbutwidth_is_zero(w, v) -> iadd(v, r) <| MR.GenD3D10PostMod_Both
or(a, b) : if( and_is_zero(a, b) ) -> iadd(a, b) <| MR.GenD3D10PostMod_Both
div(a,b)->mul(a, rcp(b)) <| MR.Gen_RequiredTranslate
lt(a, b) -> cmp(a - b, 0f, 1f) <| MR.Gen_RequiredTranslate
ge(a, b) -> cmp(a - b, 1f, 0f) <| MR.Gen_RequiredTranslate
max(a, -a) -> abs <| MR.Gen_RequiredTranslate
max(a, b) -> cmp(a - b, a, b) <| MR.Gen_RequiredTranslate
min(a, b) -> cmp(a - b, b, a) <| MR.Gen_RequiredTranslate
dmad -> dmul, dadd <| MR.Gen_RequiredTranslate
countbits(i) -> and/shift/add sequence <| MR.Gen_RequiredTranslate
firstbitlow(i) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
firstbit_shi(i) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
firstbit_hi(i) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
reversebits(i) -> and/shift/or sequence <| MR.Gen_RequiredTranslate
f32tof16(i) -> conversion sequence <| MR.Gen_RequiredTranslate
f16tof32(i) -> conversion sequence <| MR.Gen_RequiredTranslate
ubfe(i) -> extraction sequence <| MR.Gen_RequiredTranslate
ibfe(i) -> extraction sequence <| MR.Gen_RequiredTranslate
bfi(i) -> insertion sequence <| MR.Gen_RequiredTranslate
preshader abs -> max(i, neg(i)) <| MR.Gen_RequiredTranslate_Preshader
preshader sat -> min(max(i, 0), 1) <| MR.Gen_RequiredTranslate_Preshader
cmp sequence 1 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
cmp sequence 2 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
pos cmp sequence -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
max(i, neg(i)) -> abs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
dmax(i, dneg(i)) -> dabs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
cmp (a, a, -a) -> abs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
min 1/max 0 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
max 0/min 1 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
dmin 1/dmax 0 -> dsat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
dmax 0/dmin 1 -> dsat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
(n & a) | r : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
(a & n) | r : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r | (n & a) : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r | (a & n) : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
a | r : if( known_bfi_bitmask_noshift_impmask(a,r) && and_is_zero(a,r) ) -> bfi(bfi_bitwidth_noshift_impmask(a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r | a : if( known_bfi_bitmask_noshift_impmask(a,r) && and_is_zero(a,r) ) -> bfi(bfi_bitwidth_noshift_impmask(a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
((a << m) & n) | i : if( known_bfi_bitmask_postshift_ignore(n,a,m,i) ) -> bfi(bfi_bitwidth_postshift_ignore(n,a,m,i), m, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
imul(a, iv_pow2) -> ishl(a, get_lowest_bit(iv_pow2)) <| MR.GenD3D10_OptimizeEarlyTranslate
udiv(a, iv_pow2) -> ushr(a, get_lowest_bit(iv_pow2)) <| MR.GenD3D10_OptimizeEarlyTranslate
(a << n) >> (m) -> ibfe(32-m, m-n, a) <| MR.GenD3D10_OptimizeEarlyTranslate
b = ubfe/ushr(a,o), movc((b >> o) & iv_pow2, bfi(w, 0, b, -iv_pow2)) -> ibfe(get_first_bit(iv_pow2), 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
b = ubfe/ushr(a,o), movc((a >> o) & iv_pow2, b | -iv_pow2) -> ibfe(get_first_bit(iv_pow2), 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, bfi(w, 0, b, -iv_pow2), b) -> ibfe(get_first_bit(iv_pow2), 0, b) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, bfi(w, 0, (b & m), -iv_pow2)) -> ibfe(get_first_bit(iv_pow2), 0, (b&m)) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, b | -iv_pow2, b) -> ibfe(get_first_bit(iv_pow2), 0, b) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, (b & m) | -iv_pow2, b) -> ibfe(get_first_bit(iv_pow2), 0, (b&m)) <| MR.GenD3D10_OptimizeEarlyTranslate
(a << n) >> (m) -> ubfe(32-m, m-n, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ((iv_pow2 << n) - 1)) -> bfi(iv_pow2 + n, 0, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ~((iv_pow2 << n) - 1)) -> bfi(iv_pow2 + n, 0, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ~(((iv_pow2 << n) - 1) << o) -> bfi(iv_pow2 + n, o, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ~(((iv_pow2 << n) << ov) + (-1 << ov))) -> bfi(iv_pow2 + n, ov, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
((a >> o1) << o2) : if( o1 == o2 ) -> bfi(o, 0, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | ((iv_pow2 << n) - 1)) -> bfi(iv_pow2 + n, 0, -1, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | (((iv_pow2 << n) - 1) << o)) -> bfi(iv_pow2 + n, o, -1, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | (((iv_pow2 << n) << ov) + (-1 << ov))) -> bfi(iv_pow2 + n, ov, -1, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | (b << n)) : if(known_bfi_bitwidth_impmask(a, b, n)) -> bfi(get_bfi_bitwidth_impmask(a, b, n), n, b, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) << m : if( known_bfi_bitmask(a,n,m) ) -> bfi(bfi_bitwidth(a,n,m), m, n, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) | i << m : if( known_bfi_bitmask_ignore(a,n,i,m) ) -> bfi(bfi_bitwidth_ignore(a,n,i,m), m, n | i, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) << m : if( known_bfi_bitmask(n,a,m) ) -> bfi(bfi_bitwidth(n,a,m), m, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a << m) & n : if( known_bfi_bitmask_postshift(n,a,m) ) -> bfi(bfi_bitwidth_postshift(n,a,m), m, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) >> m : if( known_ubfe_bitmask(a,n,m) ) -> ubfe(ubfe_bitwidth(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) >> m : if( known_ubfe_bitmask(n,a,m) ) -> ubfe(bitwidth(n,a,m), m, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(int)(a & n) >> m : if( high_bit_clear(a & n) && known_ubfe_bitmask(a,n,m) ) -> ubfe(bitwidth(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
(int)(a & n) >> m : if( high_bit_clear(a & n) && known_ubfe_bitmask(n,a,m) ) -> ubfe(ubfe_bitwidth(n,a,m), m, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a >> m) & n : if( known_ubfe_bitmask_nomaskshift(a,n,m) ) -> ubfe(ubfe_bitwidth_nomaskshift(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
(a >> m) & n : if( high_bit_clear(a & n) && known_ubfe_bitmask_nomaskshift(a,n,m) ) -> ubfe(ubfe_bitwidth_nomaskshift(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
dcl_func_output(a) -> o->append_dataflow() <| SMR.DataflowAnalysis
bind_load(chain, value) -> o->append_sources(chain) <| SMR.DataflowAnalysis
loop_in(completed a) -> o->append_inloop() <| SMR.RangeDataAnalysis
$IsStandardLoad(a, chain) -> append_addressed(o, chain) (range/flag prop) <| SMR.RangeDataAnalysis
$IsResLoad(uav, a, addr, offs, mask) -> append_arg(sources(o, a)) <| SMR.RangeDataAnalysis
movc(true,b,c) -> append_arg(b) <| SMR.RangeDataAnalysis
movc(false,b,c) -> append_arg(b) <| SMR.RangeDataAnalysis
movc(a,b,c) -> append_arg(b, c) <| SMR.RangeDataAnalysis
cmp(a,b,c) -> append_arg(b, c) <| SMR.RangeDataAnalysis
ignore move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
ignore double move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
pred move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
tunnelable move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
and(btrue,a) -> append_arg(a) <| SMR.RangeDataAnalysis
and(false,a) -> append_arg(0,a) <| SMR.RangeDataAnalysis
or(bfalse,a) -> append_arg(a) <| SMR.RangeDataAnalysis
or(true,a) -> append_arg(true,a) <| SMR.RangeDataAnalysis
mul(1f,a) -> append_arg(a) <| SMR.RangeDataAnalysis
add(0f,a) -> append_arg(a) <| SMR.RangeDataAnalysis
mul(fbool,a) -> append_arg(0f,a) <| SMR.RangeDataAnalysis
mul(fbool,finite a) -> append_arg(0f,a) <| SMR.RangeDataAnalysis
lerp(fbool, a, b) -> append_arg(a,b) <| SMR.RangeDataAnalysis
lerp(fbool, finite a, finite b) -> append_arg(a,b) <| SMR.RangeDataAnalysis
lerp(fbool, a, 0) -> append_arg(a,0) <| SMR.RangeDataAnalysis
lerp(fbool, finite a, 0) -> append_arg(a,0) <| SMR.RangeDataAnalysis
a + -a -> append_arg(0) <| SMR.RangeDataAnalysis
(a + F) - a -> append_arg(F) <| SMR.RangeDataAnalysis
a + (F - a) -> append_arg(F) <| SMR.RangeDataAnalysis
(a + F1) - (a + F2) -> append_arg(F1-F2) <| SMR.RangeDataAnalysis
finite a + -a -> append_arg(0) <| SMR.RangeDataAnalysis
i + -i -> append_arg(0) <| SMR.RangeDataAnalysis
(i + I) - i -> append_arg(I) <| SMR.RangeDataAnalysis
i + (I - i) -> append_arg(I) <| SMR.RangeDataAnalysis
(i + I1) - (i + I2) -> append_arg(I1-I2) <| SMR.RangeDataAnalysis
endif(a,b) -> append_arg(a,b) <| SMR.RangeDataAnalysis
$IsMultiWriteOut(a, chain) -> append_sources(a) <| SMR.RangeDataAnalysis
o = dfuse(ab) -> o->append_dfuse() <| SMR.DataFlagAnalysis
loop_in(completed a) -> o->append_inloop() <| SMR.DataFlagAnalysis
loop_endif(a) -> append_arg(a, pred_a) <| SMR.DataFlagAnalysis
function_endif(a) -> append_arg(a, pred_a) <| SMR.DataFlagAnalysis
cl = $IsBreak(a, ci) -> append_arg(a, ci) <| SMR.DataFlagAnalysis
cl = $IsContinue(a, ci) -> append_arg(a, ci) <| SMR.DataFlagAnalysis
cf = $IsReturn(a, ci) -> append_arg(a, ci) <| SMR.DataFlagAnalysis
cl = $IsConsume(a, b, ci) -> append_arg(ci) <| SMR.DataFlagAnalysis
endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis
loop_endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis
function_endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis
chain_merge($IsSync() || chain) -> append_arg(sync) <| SMR.DataFlagAnalysis_ConstInterp
$IsStandardLoad(a, chain) -> append_addressed(o, chain), append_arg(a, chain) <| SMR.DataFlagAnalysis_PlaceHolder
$IsAtomicAllocConsume(a, res) -> append_arg(all_sources(o, a)) <| SMR.DataFlagAnalysis_PlaceHolder
$IsTwoValueAtomic(chain, res, addr, op1, op2) -> append_arg(all_sources(o, chain), chain, addr, op1, op2) <| SMR.DataFlagAnalysis_PlaceHolder
$IsBasicOrImmAtomic(a, res, addr, op) -> append_arg(all_sources(o, a), a, addr, op) <| SMR.DataFlagAnalysis_PlaceHolder
$IsResLoad(uav, a, addr, offs, mask) -> append_arg(all_sources(o, a), uav, a, addr, offs, mask) <| SMR.DataFlagAnalysis_PlaceHolder
$IsStandardStore(addr, val, chain) -> append_param(chain) <| SMR.DataFlagAnalysis_PlaceHolder
$IsResStore(uav, a, addr, offs, mask, val) -> append_param(a) <| SMR.DataFlagAnalysis_PlaceHolder
cl = endcase(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_PlaceHolder
cl = fcbody_end(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_PlaceHolder
discard_endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis_PlaceHolder
$IsLoop(a) -> append_sources() (loop predicate linkage) <| SMR.DataFlagAnalysis_PlaceHolder
$IsMultiWriteOut(a, chain) -> append_sources(a) <| SMR.DataFlagAnalysis_PlaceHolder
$IsSync() -> append_all_visible+inputs(UAV chain args) <| SMR.DataFlagAnalysis_PlaceHolder
$IsStandardStore(addr, val, chain) -> append_param(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
chain_merge($IsSync() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
chain_merge(chain_merge() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
array_merge(chain_merge() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = emitarg(a, b, ci) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = emit(ci, stream) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = casecond(ci, c) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = endcase(ci, ch) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = fcbody(ci, c) -> append_arg(ci, c) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = fcbody_end(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_NoPlaceHolder
loop(a) -> append_sources() (loop predicate linkage) <| SMR.DataFlagAnalysis_NoPlaceHolder
o = $IsStandardLoad(a, chain) -> append_addressed(o, chain) (all sources) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsMultiWriteOut(a, chain) -> append_sources(a) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsAtomicAllocConsume(a, res) -> append_arg(all_sources(o, a)) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsTwoValueAtomic(chain, res, addr, op1, op2) -> append_arg(chain, addr, op1, op2) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsBasicOrImmAtomic(a, res, addr, op) -> append_arg(all_sources(o, a), addr, op) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsResLoad(uav, a, addr, offs, mask) -> append_arg(all_sources(o, a), addr, offs) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsResStore(uav, a, addr, offs, mask, val) -> append_param(a) (chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
d(x)/dz -> dx/dz <| SR.GenDerivatives_Unary
d((double)x)/dz -> (double)dx/dz <| SR.GenDerivatives_Unary
d(-x)/dz -> -dx/dz <| SR.GenDerivatives_Unary
d((double)-x)/dz -> -(double)dx/dz <| SR.GenDerivatives_Unary
d(x+eps)/dz -> dx/dz <| SR.GenDerivatives_Unary
d(1/x)/dz -> -dx/dz/x^2 <| SR.GenDerivatives_Unary
d(2^x)/dz -> ln(2) * 2^x * dx/dz <| SR.GenDerivatives_Unary
d(log_2(x))/dz -> 1/(x * ln(2)) * dx/dz <| SR.GenDerivatives_Unary
d(x^-0.5)/dz -> -0.5*x^-1.5 * dx/dz <| SR.GenDerivatives_Unary
d(sin(x))/dz -> cos(x) * dx/dz <| SR.GenDerivatives_Unary
d(cos(x))/dz -> -sin(x) * dx/dz <| SR.GenDerivatives_Unary
d(asin(x))/dz -> 1/sqrt(1-x^2) * dx/dz <| SR.GenDerivatives_Unary
d(acos(x))/dz -> -1/sqrt(1-x^2) * dx/dz <| SR.GenDerivatives_Unary
d(atan(x))/dz -> 1/(1+x^2) * dx/dz <| SR.GenDerivatives_Unary
$IsAnyDeriv(x)/dz -> $IsAnyDeriv(dx/dz) <| SR.GenDerivatives_Unary
dsy(x)/dz -> dsy(dx/dz) <| SR.GenDerivatives_Unary
sqrt(x)/dz -> 0.5 / sqrt(x) * (dx/dz) <| SR.GenDerivatives_Unary
dtof(x)/dz -> dtof(dx/dz) <| SR.GenDerivatives_Unary
ftod(x)/dz -> ftod(dx/dz) <| SR.GenDerivatives_Unary
d(min(x,y))/dz -> (x < y) ? dx/dz : ((y < x) ? dy/dz : min(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(max(x,y))/dz -> (x > y) ? dx/dz : ((y > x) ? dy/dz : max(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(dmin(x,y))/dz -> (x < y) ? dx/dz : ((y < x) ? dy/dz : dmin(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(dmax(x,y))/dz -> (x > y) ? dx/dz : ((y > x) ? dy/dz : dmax(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(x + y)/dz -> dx/dz + dy/dz <| SR.GenDerivatives_Binary
d((double)x + (double)y)/dz -> dx/dz + dy/dz <| SR.GenDerivatives_Binary
d(x * x)/dz -> 2*dx/dz * x <| SR.GenDerivatives_Binary
d((double)x * x)/dz -> 2*dx/dz * x <| SR.GenDerivatives_Binary
d(x * y)/dz -> dx/dz * y + x * dy/dz <| SR.GenDerivatives_Binary
d((double)x * y)/dz -> dx/dz * y + x * dy/dz <| SR.GenDerivatives_Binary
d(atan2(x,y))/dz -> 1 / (1 + (y/x)^2) * d(y/x)/dz <| SR.GenDerivatives_Binary
d(x / y)/dz -> dx/dz / y + x * -dy/dz / y^2 <| SR.GenDerivatives_Binary
d(a ? b : c)/dz -> a ? db/dz : dc/dz <| SR.GenDerivatives_Ternary
abs fp_flags <| SFPS
abs fp_specials <| SFPS
abs float_literal <| SFPS
abs fp_range <| SFPS
acos fp_flags <| SFPS
acos fp_specials <| SFPS
acos float_literal <| SFPS
acos fp_range <| SFPS
add fp_flags <| SFPS
add fp_specials <| SFPS
add float_literal <| SFPS
add fp_range <| SFPS
and fp_flags <| SFPS
and int_flags <| SFPS
and int_literal <| SFPS
and bits_known <| SFPS
asin fp_flags <| SFPS
asin fp_specials <| SFPS
asin float_literal <| SFPS
asin fp_range <| SFPS
atan fp_flags <| SFPS
atan fp_specials <| SFPS
atan float_literal <| SFPS
atan fp_range <| SFPS
atan2 fp_flags <| SFPS
atan2 fp_specials <| SFPS
atan2 float_literal <| SFPS
atan2 fp_range <| SFPS
bdeq fp_flags <| SFPS
bdeq int_literal <| SFPS
bdeq int_range <| SFPS
bdge fp_flags <| SFPS
bdge int_literal <| SFPS
bdge int_range <| SFPS
bdlt fp_flags <| SFPS
bdlt int_literal <| SFPS
bdlt int_range <| SFPS
bdne fp_flags <| SFPS
bdne int_literal <| SFPS
bdne int_range <| SFPS
beq fp_flags <| SFPS
beq int_literal <| SFPS
beq int_range <| SFPS
bfi fp_flags <| SFPS
bfi int_literal <| SFPS
bfi bits_known <| SFPS
bge fp_flags <| SFPS
bge int_literal <| SFPS
bge int_range <| SFPS
blt fp_flags <| SFPS
blt int_literal <| SFPS
blt int_range <| SFPS
bne fp_flags <| SFPS
bne int_literal <| SFPS
bne int_range <| SFPS
bieq fp_flags <| SFPS
bieq int_literal <| SFPS
bieq bits_known <| SFPS
bieq int_range <| SFPS
bige fp_flags <| SFPS
bige int_literal <| SFPS
bige bits_known <| SFPS
bige int_range <| SFPS
bilt fp_flags <| SFPS
bilt int_literal <| SFPS
bilt bits_known <| SFPS
bilt int_range <| SFPS
bine fp_flags <| SFPS
bine int_literal <| SFPS
bine bits_known <| SFPS
bine int_range <| SFPS
bufinfo fp_flags <| SFPS
buge fp_flags <| SFPS
buge int_literal <| SFPS
buge bits_known <| SFPS
buge int_range <| SFPS
bult fp_flags <| SFPS
bult int_literal <| SFPS
bult bits_known <| SFPS
bult int_range <| SFPS
break fp_flags <| SFPS
btof fp_flags <| SFPS
btoi fp_flags <| SFPS
btoi int_literal <| SFPS
btoi bits_known <| SFPS
btoi int_range <| SFPS
calclod1d fp_flags <| SFPS
calclod1d_a fp_flags <| SFPS
calclod1d_u fp_flags <| SFPS
calclod1d_u_a fp_flags <| SFPS
calclod2d fp_flags <| SFPS
calclod2d_a fp_flags <| SFPS
calclod2d_u fp_flags <| SFPS
calclod2d_u_a fp_flags <| SFPS
calclod3d fp_flags <| SFPS
calclod3d_u fp_flags <| SFPS
calclodcube fp_flags <| SFPS
calclodcube_a fp_flags <| SFPS
calclodcube_u fp_flags <| SFPS
calclodcube_u_a fp_flags <| SFPS
case fp_flags <| SFPS
ceil fp_flags <| SFPS
ceil fp_specials <| SFPS
ceil float_literal <| SFPS
ceil fp_range <| SFPS
chain_end fp_flags <| SFPS
cmp fp_flags <| SFPS
cmp fp_specials <| SFPS
cmp float_literal <| SFPS
cmp fp_range <| SFPS
continue fp_flags <| SFPS
cos fp_flags <| SFPS
cos fp_specials <| SFPS
cos float_literal <| SFPS
cos fp_range <| SFPS
countbits fp_flags <| SFPS
countbits int_literal <| SFPS
countbits bits_known <| SFPS
dabs fp_flags <| SFPS
dabs fp_specials <| SFPS
dabs float_literal <| SFPS
dabs fp_range <| SFPS
dadd fp_flags <| SFPS
dadd fp_specials <| SFPS
dadd float_literal <| SFPS
dadd fp_range <| SFPS
dfuse fp_flags <| SFPS
dfuse float_literal <| SFPS
dfuse fp_specials <| SFPS
dmad fp_flags <| SFPS
dmad fp_specials <| SFPS
dmad float_literal <| SFPS
dmad fp_range <| SFPS
dmax fp_flags <| SFPS
dmax fp_specials <| SFPS
dmax float_literal <| SFPS
dmax fp_range <| SFPS
dmin fp_flags <| SFPS
dmin fp_specials <| SFPS
dmin float_literal <| SFPS
dmin fp_range <| SFPS
dmov fp_flags <| SFPS
dmov mov <| SFPS
dmovc fp_flags <| SFPS
dmovc fp_specials <| SFPS
dmovc float_literal <| SFPS
dmul fp_flags <| SFPS
dmul fp_specials <| SFPS
dmul float_literal <| SFPS
dmul fp_range <| SFPS
dneg fp_flags <| SFPS
dneg fp_specials <| SFPS
dneg float_literal <| SFPS
dneg fp_range <| SFPS
dsat fp_flags <| SFPS
dsat float_literal <| SFPS
dsat fp_range <| SFPS
dsplit fp_flags <| SFPS
dsplit int_literal <| SFPS
dsplit fp_specials <| SFPS
dtof fp_flags <| SFPS
dtof float_literal <| SFPS
dtof fp_range <| SFPS
dtof fp_specials <| SFPS
discardif fp_flags <| SFPS
div fp_flags <| SFPS
div fp_specials <| SFPS
div float_literal <| SFPS
div fp_range <| SFPS
dsx fp_flags <| SFPS
dsx fp_specials <| SFPS
dsx float_literal <| SFPS
dsx fp_range <| SFPS
dsy fp_flags <| SFPS
dsy fp_specials <| SFPS
dsy float_literal <| SFPS
dsy fp_range <| SFPS
dsx_fine fp_flags <| SFPS
dsx_fine fp_specials <| SFPS
dsx_fine float_literal <| SFPS
dsx_fine fp_range <| SFPS
dsy_fine fp_flags <| SFPS
dsy_fine fp_specials <| SFPS
dsy_fine float_literal <| SFPS
dsy_fine fp_range <| SFPS
dsx_coarse fp_flags <| SFPS
dsx_coarse fp_specials <| SFPS
dsx_coarse float_literal <| SFPS
dsx_coarse fp_range <| SFPS
dsy_coarse fp_flags <| SFPS
dsy_coarse fp_specials <| SFPS
dsy_coarse float_literal <| SFPS
dsy_coarse fp_range <| SFPS
eval_centroid fp_flags <| SFPS
eval_sample fp_flags <| SFPS
eval_snapped fp_flags <| SFPS
exp fp_flags <| SFPS
exp fp_specials <| SFPS
exp float_literal <| SFPS
exp fp_range <| SFPS
f16tof32 fp_flags <| SFPS
f16tof32 float_literal <| SFPS
f16tof32 bits_known <| SFPS
f32tof16 fp_flags <| SFPS
f32tof16 int_literal <| SFPS
f32tof16 int_range <| SFPS
fcall fp_flags <| SFPS
fcbody fp_flags <| SFPS
firstbitlow fp_flags <| SFPS
firstbitlow int_literal <| SFPS
firstbitlow bits_known <| SFPS
firstbit_hi fp_flags <| SFPS
firstbit_hi int_literal <| SFPS
firstbit_hi bits_known <| SFPS
firstbit_shi fp_flags <| SFPS
firstbit_shi int_literal <| SFPS
firstbit_shi bits_known <| SFPS
floor fp_flags <| SFPS
floor fp_specials <| SFPS
floor float_literal <| SFPS
floor fp_range <| SFPS
frc fp_flags <| SFPS
frc fp_specials <| SFPS
frc float_literal <| SFPS
frc fp_range <| SFPS
ftob fp_flags <| SFPS
ftob int_literal <| SFPS
ftob int_range <| SFPS
ftod fp_flags <| SFPS
ftod float_literal <| SFPS
ftod fp_range <| SFPS
ftod fp_specials <| SFPS
ftoi fp_flags <| SFPS
ftoi int_literal <| SFPS
ftoi int_range <| SFPS
ftou fp_flags <| SFPS
ftou int_literal <| SFPS
ftou int_range <| SFPS
functionif fp_flags <| SFPS
gather2d fp_flags <| SFPS
gather2d_a fp_flags <| SFPS
gather2d_a_o fp_flags <| SFPS
gather2d_o fp_flags <| SFPS
gathercube fp_flags <| SFPS
gathercube_a fp_flags <| SFPS
gathercube_c fp_flags <| SFPS
gathercube_c_a fp_flags <| SFPS
ge fp_flags <| SFPS
ge float_literal <| SFPS
ge fp_range <| SFPS
iadd fp_flags <| SFPS
iadd int_literal <| SFPS
iadd bits_known <| SFPS
iadd int_range <| SFPS
ibfe fp_flags <| SFPS
ibfe int_literal <| SFPS
ibfe bits_known <| SFPS
idiv fp_flags <| SFPS
idiv int_literal <| SFPS
idiv bits_known <| SFPS
idiv int_range <| SFPS
imad fp_flags <| SFPS
imad int_literal <| SFPS
imad bits_known <| SFPS
imad int_range <| SFPS
imax fp_flags <| SFPS
imax int_literal <| SFPS
imax bits_known <| SFPS
imax int_range <| SFPS
imin fp_flags <| SFPS
imin int_literal <| SFPS
imin bits_known <| SFPS
imin int_range <| SFPS
imod fp_flags <| SFPS
imod int_literal <| SFPS
imod bits_known <| SFPS
imod int_range <| SFPS
imul fp_flags <| SFPS
imul int_literal <| SFPS
imul bits_known <| SFPS
imul int_range <| SFPS
ineg fp_flags <| SFPS
ineg int_literal <| SFPS
ineg bits_known <| SFPS
ineg int_range <| SFPS
ishl fp_flags <| SFPS
ishl int_literal <| SFPS
ishl bits_known <| SFPS
ishr fp_flags <| SFPS
ishr int_literal <| SFPS
ishr bits_known <| SFPS
itob fp_flags <| SFPS
itob int_literal <| SFPS
itob bits_known <| SFPS
itob int_range <| SFPS
itof fp_flags <| SFPS
load fp_flags <| SFPS
load_o fp_flags <| SFPS
tload fp_flags <| SFPS
load2d_msaa fp_flags <| SFPS
load2d_msaa_o fp_flags <| SFPS
load2darray_msaa fp_flags <| SFPS
load2darray_msaa_o fp_flags <| SFPS
log fp_flags <| SFPS
log fp_specials <| SFPS
log float_literal <| SFPS
log fp_range <| SFPS
loopif fp_flags <| SFPS
lt fp_flags <| SFPS
lt float_literal <| SFPS
lt fp_range <| SFPS
mad fp_flags <| SFPS
mad fp_specials <| SFPS
mad float_literal <| SFPS
mad fp_range <| SFPS
max fp_flags <| SFPS
max fp_specials <| SFPS
max float_literal <| SFPS
max fp_range <| SFPS
min fp_flags <| SFPS
min fp_specials <| SFPS
min float_literal <| SFPS
min fp_range <| SFPS
mov fp_flags <| SFPS
mov mov <| SFPS
movc fp_flags <| SFPS
movc fp_specials <| SFPS
movc float_literal <| SFPS
mul fp_flags <| SFPS
mul fp_specials <| SFPS
mul float_literal <| SFPS
mul fp_range <| SFPS
neg fp_flags <| SFPS
neg fp_specials <| SFPS
neg float_literal <| SFPS
neg fp_range <| SFPS
not fp_flags <| SFPS
not int_literal <| SFPS
not bits_known <| SFPS
or fp_flags <| SFPS
or int_flags <| SFPS
or int_literal <| SFPS
or bits_known <| SFPS
placement_mov fp_flags <| SFPS
placement_mov mov <| SFPS
rcp fp_flags <| SFPS
rcp fp_specials <| SFPS
rcp float_literal <| SFPS
rcp fp_range <| SFPS
rcp_approx fp_flags <| SFPS
rcp_approx fp_specials <| SFPS
rcp_approx float_literal <| SFPS
rcp_approx fp_range <| SFPS
resinfo fp_flags <| SFPS
resinfo_uint fp_flags <| SFPS
return fp_flags <| SFPS
reversebits fp_flags <| SFPS
reversebits int_literal <| SFPS
reversebits bits_known <| SFPS
round fp_flags <| SFPS
round fp_specials <| SFPS
round float_literal <| SFPS
round fp_range <| SFPS
rsq fp_flags <| SFPS
rsq fp_specials <| SFPS
rsq float_literal <| SFPS
rsq fp_range <| SFPS
sample1d fp_flags <| SFPS
sample1d_a fp_flags <| SFPS
sample1d_o fp_flags <| SFPS
sample1d_a_o fp_flags <| SFPS
sample1d_bias fp_flags <| SFPS
sample1d_bias_a fp_flags <| SFPS
sample1d_bias_o fp_flags <| SFPS
sample1d_bias_a_o fp_flags <| SFPS
sample1d_bias_l fp_flags <| SFPS
sample1d_c fp_flags <| SFPS
sample1d_c_a fp_flags <| SFPS
sample1d_c_o fp_flags <| SFPS
sample1d_c_a_o fp_flags <| SFPS
sample1d_c_lz fp_flags <| SFPS
sample1d_c_lz_a fp_flags <| SFPS
sample1d_c_lz_o fp_flags <| SFPS
sample1d_c_lz_a_o fp_flags <| SFPS
sample1d_dd fp_flags <| SFPS
sample1d_dd_a fp_flags <| SFPS
sample1d_dd_o fp_flags <| SFPS
sample1d_dd_a_o fp_flags <| SFPS
sample1d_lod fp_flags <| SFPS
sample1d_lod_a fp_flags <| SFPS
sample1d_lod_o fp_flags <| SFPS
sample1d_lod_a_o fp_flags <| SFPS
sample1d_lod_l fp_flags <| SFPS
sample2d fp_flags <| SFPS
sample2d_a fp_flags <| SFPS
sample2d_o fp_flags <| SFPS
sample2d_a_o fp_flags <| SFPS
sample2d_dd fp_flags <| SFPS
sample2d_dd_a fp_flags <| SFPS
sample2d_dd_o fp_flags <| SFPS
sample2d_dd_a_o fp_flags <| SFPS
sample2d_lod fp_flags <| SFPS
sample2d_lod_a fp_flags <| SFPS
sample2d_lod_o fp_flags <| SFPS
sample2d_lod_a_o fp_flags <| SFPS
sample2d_c fp_flags <| SFPS
sample2d_c_a fp_flags <| SFPS
sample2d_c_o fp_flags <| SFPS
sample2d_c_a_o fp_flags <| SFPS
sample2d_c_lz fp_flags <| SFPS
sample2d_c_lz_a fp_flags <| SFPS
sample2d_c_lz_o fp_flags <| SFPS
sample2d_c_lz_a_o fp_flags <| SFPS
sample2d_bias fp_flags <| SFPS
sample2d_bias_a fp_flags <| SFPS
sample2d_bias_o fp_flags <| SFPS
sample2d_bias_a_o fp_flags <| SFPS
sample2d_lod_l fp_flags <| SFPS
sample2d_bias_l fp_flags <| SFPS
sample3d fp_flags <| SFPS
sample3d_o fp_flags <| SFPS
sample3d_dd fp_flags <| SFPS
sample3d_dd_o fp_flags <| SFPS
sample3d_lod fp_flags <| SFPS
sample3d_lod_o fp_flags <| SFPS
sample3d_bias fp_flags <| SFPS
sample3d_bias_o fp_flags <| SFPS
sample3d_lod_l fp_flags <| SFPS
sample3d_bias_l fp_flags <| SFPS
samplecube fp_flags <| SFPS
samplecube_dd fp_flags <| SFPS
samplecube_lod fp_flags <| SFPS
samplecube_c fp_flags <| SFPS
samplecube_c_a fp_flags <| SFPS
samplecube_c_lz fp_flags <| SFPS
samplecube_c_lz_a fp_flags <| SFPS
samplecube_bias fp_flags <| SFPS
samplecube_a fp_flags <| SFPS
samplecube_dd_a fp_flags <| SFPS
samplecube_lod_a fp_flags <| SFPS
samplecube_bias_a fp_flags <| SFPS
samplecube_lod_l fp_flags <| SFPS
samplecube_bias_l fp_flags <| SFPS
sampleinfo fp_flags <| SFPS
sampleinfo_uint fp_flags <| SFPS
sampleinfo_rt fp_flags <| SFPS
sampleinfo_uint_rt fp_flags <| SFPS
samplepos fp_flags <| SFPS
samplepos_rt fp_flags <| SFPS
sat fp_flags <| SFPS
sat float_literal <| SFPS
sat fp_range <| SFPS
sin fp_flags <| SFPS
sin fp_specials <| SFPS
sin float_literal <| SFPS
sin fp_range <| SFPS
sincos fp_flags <| SFPS
sincos fp_specials <| SFPS
sincos float_literal <| SFPS
sincos fp_range <| SFPS
sqrt fp_flags <| SFPS
sqrt fp_specials <| SFPS
sqrt float_literal <| SFPS
sqrt fp_range <| SFPS
switch fp_flags <| SFPS
tex1d fp_flags <| SFPS
tex1d_bias fp_flags <| SFPS
tex1d_dd fp_flags <| SFPS
tex1d_lod fp_flags <| SFPS
tex1d_proj fp_flags <| SFPS
tex2d fp_flags <| SFPS
tex2d_bias fp_flags <| SFPS
tex2d_dd fp_flags <| SFPS
tex2d_lod fp_flags <| SFPS
tex2d_proj fp_flags <| SFPS
tex3d fp_flags <| SFPS
tex3d_bias fp_flags <| SFPS
tex3d_dd fp_flags <| SFPS
tex3d_lod fp_flags <| SFPS
tex3d_proj fp_flags <| SFPS
texcube fp_flags <| SFPS
texcube_bias fp_flags <| SFPS
texcube_dd fp_flags <| SFPS
texcube_lod fp_flags <| SFPS
texcube_proj fp_flags <| SFPS
trunc fp_flags <| SFPS
trunc fp_specials <| SFPS
trunc float_literal <| SFPS
trunc fp_range <| SFPS
uaddc fp_flags <| SFPS
uaddc int_literal <| SFPS
uaddc bits_known <| SFPS
uaddc int_range <| SFPS
ubfe fp_flags <| SFPS
ubfe int_literal <| SFPS
ubfe bits_known <| SFPS
usubb fp_flags <| SFPS
usubb int_literal <| SFPS
usubb bits_known <| SFPS
usubb int_range <| SFPS
udiv fp_flags <| SFPS
udiv int_literal <| SFPS
udiv bits_known <| SFPS
udiv int_range <| SFPS
umax fp_flags <| SFPS
umax int_literal <| SFPS
umax bits_known <| SFPS
umax int_range <| SFPS
umin fp_flags <| SFPS
umin int_literal <| SFPS
umin bits_known <| SFPS
umin int_range <| SFPS
umod fp_flags <| SFPS
umod int_literal <| SFPS
umod bits_known <| SFPS
umod int_range <| SFPS
umul fp_flags <| SFPS
umul int_literal <| SFPS
umul bits_known <| SFPS
umul int_range <| SFPS
ushr fp_flags <| SFPS
ushr int_literal <| SFPS
ushr bits_known <| SFPS
utof fp_flags <| SFPS
xor fp_flags <| SFPS
xor int_flags <| SFPS
xor int_literal <| SFPS
xor bits_known <| SFPS
break_consume fp_flags <| SFPS
continue_consume fp_flags <| SFPS
loopif_consume fp_flags <| SFPS
output_consume fp_flags <| SFPS
return_consume fp_flags <| SFPS
sync_g fp_flags <| SFPS
sync_ug fp_flags <| SFPS
sync_up fp_flags <| SFPS
sync_g_ug fp_flags <| SFPS
sync_g_up fp_flags <| SFPS
sync_g_t fp_flags <| SFPS
sync_ug_t fp_flags <| SFPS
sync_up_t fp_flags <| SFPS
sync_g_ug_t fp_flags <| SFPS
sync_g_up_t fp_flags <| SFPS
arraystore fp_flags <| SFPS
arrayload fp_flags <| SFPS
bind_load fp_flags <| SFPS
atomic_and fp_flags <| SFPS
atomic_or fp_flags <| SFPS
atomic_xor fp_flags <| SFPS
atomic_iadd fp_flags <| SFPS
atomic_imax fp_flags <| SFPS
atomic_imin fp_flags <| SFPS
atomic_umax fp_flags <| SFPS
atomic_umin fp_flags <| SFPS
atomic_cmp_store fp_flags <| SFPS
imm_atomic_and fp_flags <| SFPS
imm_atomic_or fp_flags <| SFPS
imm_atomic_xor fp_flags <| SFPS
imm_atomic_iadd fp_flags <| SFPS
imm_atomic_imax fp_flags <| SFPS
imm_atomic_imin fp_flags <| SFPS
imm_atomic_umax fp_flags <| SFPS
imm_atomic_umin fp_flags <| SFPS
imm_atomic_exch fp_flags <| SFPS
imm_atomic_cmp_exch fp_flags <| SFPS
imm_atomic_alloc fp_flags <| SFPS
imm_atomic_consume fp_flags <| SFPS
Needs to be replaced with a real rule
IEEE-safe mode clamps float literals to 32-bit values, %g is losing precision (this warning will only be shown once per compile)
32-bit floating-point operations flush denorm float literals to zero, %g is losing precision (this warning will only be shown once per compile)
(unknown)
%s semantic '%s'
internal warning: optimization did not converge
multiple variables found with the same user-specified location
gradient-based operations must be moved out of flow control to prevent divergence. Performance may improve by using a non-gradient operation
cannot have gradient operations inside loops with divergent flow control
internal error: argument pulled into unrelated predicate
cannot have divergent gradient operations inside flow control
Reading from texture buffers is unsupported on %s
Shader uses texture addressing operations in a dependency chain that is too complex for the target shader model (%s) to handle.
internal error: invalid register
preshader
variable '%s' used without having been completely initialized <| A%u (B%u), I%u (B%u)
race condition may make sync dependent on this potentially varying variable: %s
thread sync operation must be in non-varying flow control, due to a potential race condition this sync is illegal, consider adding a sync after the value used to control the flow at this location is calculated
internal warning: values did not converge
internal error: component out of range
floating point division by zero
imaginary square root
indefinite logarithm
indefinite arcsine
indefinite arccosine
Literal float out of integer range for conversion: %f
Literal float out of unsigned range for conversion: %f
sum of %g and %g cannot be represented accurately in double precision
Integer divide by zero
Unsigned integer divide by zero
Floating-point Value out of integer range for conversion: %f
Floating-point Value out of unsigned range for conversion: %f
indefinite derivative calculation
Possible integer divide by zero
Derivative being used before it was defined. If you used the assignment syntax, consider moving it earlier in the program.
Derivative is not defined in this branch of flow-control. If you used the assignment syntax, consider moving the assignment before any flow control statements.
Redefinition of derivative, derivatives may only be assigned once.
Derivatives of known values are unimplemented.
Unable to calculate derivative of this operation. Consider using the assignment syntax to calculate it yourself (e.g.: x`(y) = z)
internal error: instruction list too long
internal error: instruction list and count mismatch
internal error: argument used without having been initialized <| A%u (B%u), I%u (B%u)
internal error: output argument was never initialized <| (A%u (B%u))
internal error: cannot write to argument pool <| (A%u (B%u), I%u (B%u))
internal error: cannot read from argument pool <| (A%u (B%u))
internal error: 64-bit arg component %u not aligned <| A%u (B%u)
internal error: reading from value known not to be read <| (A%u (B%u))
internal error: argument was never used <| (A%u (B%u), I%u (B%u))
internal error: argument was never used <| (A%u (B%u))
Use of potentially uninitialized variable (%s)
Internal error: unpredicated endif input
Internal error: invalid read of more specific predicate
internal error: unpredicated incomplete
internal error: unpredicated loop_in
Internal error: unread predicate
overlapping register semantics not yet implemented 'c%u'
SV_TARGET
SV_DEPTH
SV_DEPTHGREATEREQUAL
SV_DEPTHLESSEQUAL
SV_COVERAGE
$Invalid
No include handler specified, can't perform a #include. Use D3DX APIs or provide your own include handler.
failed to open source file: '%s'
unexpected tokens following preprocessor directive
unexpected end of file
__FILE__
__LINE__
DIRECT3D
D3D10_COMPILER
HLSL_VERSION
D3DX_VERSION
include
defined
invalid or unsupported integer constant expression
division by zero in preprocessor expression
invalid preprocessor command '%s'
duplicate macro parameter '%s'
include interface required to support #include from resource or memory
too many nested #includes
error: %s
unexpected #elif
unexpected #elif following #else
unexpected #else
unexpected #else following #else
unexpected #endif
pack_matrix
warning
ruledisable
message
'%s' : unknown pragma ignored
disable
'%s' : macro redefinition
functional defines in preprocessor expressions not yet implemented
unexpected end of file in macro expansion
not enough actual parameters for macro '%s'
1.#SNAN
1.#QNAN
(%u,%u): 
%s X%u: 
Error creating error string
warning treated as error
Unable to create warning string
integer '%u'
integer '%dl'
integer '%uul'
integer '%I64'
integer '%u64u64'
float '%g'
float '%gh'
float '%gf'
float '%gl'
syntax error : unexpected %s
comment continues past end of file
hex value truncated to 64 bits
octal value truncated to 64 bits
decimal value truncated to 64 bits
string continues past end of file
string continues past end of line
character continues past end of file
finalTriWEdgeTessFactor
finalTriVEdgeTessFactor
finalTriUEdgeTessFactor
D3D11 Assembler Error: Invalid Bytecode: %s
D3D11 Internal Compiler Error: Invalid Bytecode: %s
Validation Error: %s
Bytecode appears corrupt - integrity check failed.
Failed to extract driver shader code.
Failed to extract input signature.
Failed to extract output signature.
ShaderFeatureInfo blob must not specify 4x raw and structured buffers for Compute Shaders, or for any shader 5_0+.
Failed to extract patch constant signature.
Unrecognized shader type.
Failed to parse shader using reference shader parser: 0x%x
Invalid interface metadata: too many instances.
Invalid interface metadata: too many types.
Invalid interface metadata: too many interface slots.
Invalid interface metadata: no types defined.
Invalid interface metadata: instance buffer overrun.
Invalid interface metadata: type buffer overrun.
Invalid interface metadata: interface buffer overrun.
Invalid interface metadata: interface %u unimplemented.
Invalid interface metadata: duplicated type in interface %d's type list.
Invalid interface metadata: interface count mismatch.
Invalid interface metadata: type %d violates type stride limits.
Invalid interface metadata: type name buffer overrun.
Invalid interface metadata: unterminated type name.
Invalid interface metadata: instance type buffer overrun.
Invalid interface metadata: variable %d violates limits on member offsets.
Invalid interface metadata: instance name buffer overrun.
Invalid interface metadata: unterminated instance name.
Can't continue validation - aborting.
label (%d) already defined. Opcode #%d (count 1-based). 
function body (%d) defined without being declared. Opcode #%d (count 1-based). 
function body (%d) referenced without being defined. Opcode #%d (count 1-based). 
function body (%d) already declared. Opcode #%d (count 1-based). 
Declaration statements must appear before other instructions.
Incorrect number of operands for opcode #%d (count is 1-based).  Expecting %d, encountered %d.
Saturate modifier not permitted for opcode #%d (counts are 1-based). 
Precise mask not permitted for opcode #%d (counts are 1-based). 
Resource dimension and return type extended opcodes not expected on opcode #%d (counts are 1-based). 
Invalid operand type for operand #%d of opcode #%d (counts are 1-based). 
Expected component count of 0 for operand #%d of opcode #%d (counts are 1-based). 
Expected component count of 1 (or 4 component with select-1 mode) for operand #%d of opcode #%d (counts are 1-based). 
Expected component count of 4 (or 1 component immediate32, or in certain cases NULL or scalar operand allowed) for operand #%d of opcode #%d (counts are 1-based). 
Expected nonzero component mask (or in certain cases also NULL or single component output operand allowed) for operand #%d of opcode #%d (counts are 1-based). 
Expected single component mask (or in certain cases also NULL or single component output operand allowed) for operand #%d of opcode #%d (counts are 1-based). 
Expected contiguous component mask starting at x (.x, .xy, .xyz, or .xyzw) for operand #%d of opcode #%d (counts are 1-based). 
Expected a component mask which picks any one or 2 components for operand #%d of opcode #%d (counts are 1-based). 
Expected double-compatible component mask (xy, zw, or xyzw) for operand #%d of opcode #%d (counts are 1-based). 
Expected double-compatible swizzle for operand #%d of opcode #%d (counts are 1-based). 
Negate modifier not allowed for operand #%d of opcode #%d (counts are 1-based). 
Abs modifier not allowed for operand #%d of opcode #%d (counts are 1-based). 
.rrrr swizzle expected for operand #%d of opcode #%d (counts are 1-based). 
Only immediate32 indexing permitted for operand #%d of opcode #%d (counts are 1-based). Aborting.
Indexing of t# resources with current instruction requires opcode to specify resource dimension and return type. Operand #%d of opcode #%d (counts are 1-based). Aborting.
4 component with no swizzle expected for operand #%d of opcode #%d (counts are 1-based). 
Unexpected indexing dimension for operand #%d of opcode #%d (counts are 1-based). Aborting.
Invalid indexing mode for first dimension.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid index dimension %d for relative address temp register within dimension 1 of operand.  Opcode #%d, operand #%d (counts are 1-based). 
Index Dimension %d's relative address temp is out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Invalid index dimension for relative address indexable temp register within dimension %d of operand.  Opcode #%d, operand #%d (counts are 1-based). 
Index Dimension %d's relative address indexable temp is out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Index Dimension %d's relative address indexable temp's dimension %d index is out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Invalid relative indexing register type for dimension %d.  Operand #%d of opcode #%d (counts are 1-based). Aborting.
Index Dimension %d out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Invalid representation for index dimension %d.  Opcode #%d, operand #%d (counts are 1-based). 
function body (%d) was never referenced.
function body (%d) was never defined.
function table (%d) was declared, but never referenced.
Interface metadata instance %d refers to undeclared constant buffer %d.
Interface metadata instance %d refers to undeclared constant buffer offset [%d,%d].
Interface metadata instance %d refers to undeclared texture %d.
Interface metadata instance %d refers to undeclared sampler %d.
Interface metadata expects interface %d to be declared, but it was not.
Interface metadata expects interface %d to be of size %d, but it was declared as size %d.
interface pointer (%d) was declared, but never referenced.
GS input primitive not declared. 
GS has no input primitive, so no input regisers may be declared.  Input v[][%d] was declared.
All GS input v[][] registers must have vertex count (first dimension) declared with size equal to the number of vertices in the declared input primitive (%d vertices in this case). Input %d has %d vertices declared. 
GS output topology not declared for stream m%d. 
GS output topology not declared. 
Interpolation mode for PS input position must be linear_noperspective_centroid or linear_noperspective_sample when outputting oDepthGE or oDepthLE and not running at sample frequency (which is forced by inputting SV_SampleIndex or declaring an input linear_sample or linear_noperspective_sample). 
Compute Shader must declare a thread group size (X,Y,Z).
Thread local temp register storage in Compute Shader (per thread) %d. The shader declares too much temp storage (%d registers). 
For Compute Shader versions < 5_0, the element count for all Structured Thread Group Shared Memory declarations 
must be equal to the number of threads in the group (%d in this case).  %d elements were specified for g%d. 
For Compute Shader versions < 5_0, with %d threads in a group, at most %d bytes per thread of Thread Group Shared Memory 
can be declared (the amount is a function of how many threads there are).  This shader exceeds the limit at %d bytes per thread. 
Domain Shader must declare an input control point count.
Domain Shader must declare a tessellator domain.
Domain Shader input vDomain must be declared with at most a .xyz mask when the domain is TRI.
Domain Shader input vDomain must be declared with at most a .xy mask when the domain is QUAD.
Domain Shader input vDomain must be declared with at most a .xy mask when the domain is ISOLINE.
All DS input control point vcp[][] registers must have control point count (first dimension) declared with size equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
Total number of scalars across all DS input control points must not exceed %d. Current input control point declaration specifies %d scalars of output per control point with %d output control points, resulting in %d total scalars of input control point data. 
Input index range defined from %d to %d includes input register %s[%d] that was not declared. 
Registers in an input index range cannot have system names associated with them (TessFactors are an exception).  Input register %s[%d] has a name and is in an index range from %d to %d. 
Masks (and if pixel shader, also interpolation mode) on all input registers in an index range must be identical. Input register %s[%d] does not match with others in the index range from %d to %d. 
Named register components cannot appear to the left (xyzw order) of components that are not named in a given register. TessFactors are an exception. Affected register is input %d. 
Named register components cannot appear to the left (xyzw order) of components that are not named in a given register. TessFactors are an exception. Affected register is output %d in stream m%d. 
Named register components cannot appear to the left (xyzw order) of components that are not named in a given register. TessFactors are an exception. Affected register is output %d. 
Mismatch between shader declaration of double precision floats and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare double precision float use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Mismatch between shader declaration of raw and structured buffers for shader 4_x and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare raw and structured buffer use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Raw or Structured buffers can't be declared in shader model 4_* VS/GS/PS without enabling them via a global flags declaration.. 
CB[%d] already declared, repeated declaration on opcode #%d (count is 1-based). 
Immediate constant buffer already declared, repeated declaration on opcode #%d (count is 1-based). 
Immediate constant buffer size must be a multiple (not incl. 0) of 32bit*4-tuples in size, but no larger than %d 32bit*4-tuples (%d bytes declared).  Opcode #%d (count is 1-based). 
Temp decl already encountered.  Repeated declaration on opcode #%d (count is 1-based). 
Too many temp registers declared (%d).  Max allowed is %d.  Opcode #%d (count is 1-based). 
Sum of temp registers and indexable temp registers exceeds limit of %d..  Opcode #%d (count is 1-based). 
Indexable temp register index, [%d], too high.  Opcode #%d (count is 1-based). Aborting.
Indexable temp x%d already declared.  Opcode #%d (count is 1-based). 
Sum of temp registers and indexable temp registers exceeds limit of %d..  Opcode #%d (count is 1-based). Aborting. 
Invalid component mask in indexable temp decl: 0x%x.  Opcode #%d (count is 1-based). Aborting. 
Resource t%d already declared.  Opcode #%d (count is 1-based). 
Expected sample count of 0 but encountered %d for resource t%d.  Opcode #%d (count is 1-based). 
Texture2DMS resources are only available for input to Pixel Shaders. Opcode #%d (count is 1-based). 
Expected sample count > 0 but encountered %d for resource t%d.  Opcode #%d (count is 1-based). 
Invalid resource dimension on resource t%d.  Opcode #%d (count is 1-based). 
Invalid resource return type on component %d of resource t%d.  Opcode #%d (count is 1-based). 
Sampler s%d already declared.  Opcode #%d (count is 1-based). 
Invalid sampler mode on sampler s%d.  Opcode #%d (count is 1-based). 
The first stream declaration cannot appear after any output or output topology declarations.  Opcode #%d (count is 1-based). 
Invalid stream index s%d.  Index must be between 0 and %d Opcode #%d (count is 1-based). 
Stream s%d already declared.  Opcode #%d (count is 1-based). 
Input index range declaration out of range.  Opcode #%d (count is 1-based). 
Overlapping input index range decl encountered.  Opcode #%d (count is 1-based). 
Output index range declaration out of range.  Opcode #%d (count is 1-based). 
Overlapping output index range decl encountered.  Opcode #%d (count is 1-based). 
GS output topology in stream m%d already declared.  Opcode #%d (count is 1-based). 
GS output topology already declared.  Opcode #%d (count is 1-based). 
GS output primitive topology unrecognized.  Opcode #%d (count is 1-based). 
GS output vertex count declaration can't be more than %d vertices (%d specified).  Opcode #%d (count is 1-based). 
GS instance count already declared.  Opcode #%d (count is 1-based). 
GS instance count declaration cannot be greater than %d (%d specified).  Opcode #%d (count is 1-based). 
GS instance count must be at least 1 (%d specified).  Opcode #%d (count is 1-based). 
GS input primitive already declared.  Opcode #%d (count is 1-based). 
GS input primitive can be a patch only if the GS version is gs_5_0 and greater.  Opcode #%d (count is 1-based). 
GS input primitive unrecognized.  Opcode #%d (count is 1-based). 
vCycleCounter is only supported on 5_0+ shaders.  Opcode #%d (count is 1-based). 
Cycle Counter already declared.  Opcode #%d (count is 1-based). 
Cycle Counter declaration must have mask of .x or .xy.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID declaration must have a non-empty mask and allows only components x, y, and z in mask.  Opcode #%d (count is 1-based). 
Compute Shader input Thread Group ID already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread Group ID declaration must have a non-empty mask and allows only components x, y, and z in mask.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group declaration must have a non-empty mask and allows only components x, y, and z in mask.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group Flattened already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group Flattened declaration must have an empty writemask.  Opcode #%d (count is 1-based). 
Input primitive ID already declared in this HS phase.  Opcode #%d (count is 1-based). 
Hull Shader output control point ID already declared.  Opcode #%d (count is 1-based). 
Hull Shader fork phase instance ID already declared.  Opcode #%d (count is 1-based). 
Hull Shader join phase instance ID already declared.  Opcode #%d (count is 1-based). 
When there is no Control Point phase in the HS, the control points are pass-through to the DS, but the Fork/Join phases in the HS cannot use 'output control points' (vocp[][] registers).  Instead just use vcp[][] input control points (which are the same anyway in the passthrough case). Opcode #%d (count is 1-based).
Input primitive ID already declared.  Opcode #%d (count is 1-based). 
Input domain point already declared.  Opcode #%d (count is 1-based). 
Input domain point declaration can't have an empty mask.  Opcode #%d (count is 1-based). 
GS input primID already declared.  Opcode #%d (count is 1-based). 
GS instance ID already declared.  Opcode #%d (count is 1-based). 
PS input vCoverage already declared.  Opcode #%d (count is 1-based). 
Components of input declaration for register %d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
Invalid name or shader for SGV dcl.  Opcode #%d (count is 1-based). 
SGV must have scalar mask in declaration.  Opcode #%d (count is 1-based). 
vertexID already declared for input.  Opcode #%d (count is 1-based). 
instanceID already declared for input.  Opcode #%d (count is 1-based). 
Invalid name or shader for SIV dcl.  Opcode #%d (count is 1-based). 
TessFactors must each be declared with a single component.  Opcode #%d (count is 1-based). 
finalQuad*TessFactor requires QUAD tessellator domain.  Opcode #%d (count is 1-based). 
finalTri*TessFactor requires TRI tessellator domain.  Opcode #%d (count is 1-based). 
finalLine*TessFactor requires ISOLINE tessellator domain.  Opcode #%d (count is 1-based). 
finalQuadUeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadVeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadUeq1EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadVeq1EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadUInsideTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadVInsideTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriUeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriVeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriWeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriInsideTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalLineDetailTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalLineDensityTessFactor already declared for input.  Opcode #%d (count is 1-based). 
position already declared for input.  Opcode #%d (count is 1-based). 
Too many unique registers contain clip/cull distance values.  At most %d unique registers can have clip/cull distance in components.  Opcode #%d (count is 1-based). 
Too many total clip/cull distance values.  At most %d allowed (clip+cull total).  Opcode #%d (count is 1-based). 
Components of input declaration for register v%d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
Invalid interpolation mode for register v%d.  Opcode #%d (count is 1-based). 
Interpolation mode cannot vary for different components of a single input register (v%d).  Opcode #%d (count is 1-based). 
primitiveID already declared for input.  Opcode #%d (count is 1-based). 
isFrontFace already declared for input.  Opcode #%d (count is 1-based). 
sampleIndex already declared for input.  Opcode #%d (count is 1-based). 
Interpolation mode for PS SGV must be constant (register v%d).  Opcode #%d (count is 1-based). 
Interpolation mode for PS input position must be linear_noperspective or linear_noperspective_centroid (shader model 4.1+ allows linear_noperspective_sample as well). 
Interpolation mode for PS clip or cull distance must be linear or linear centroid, or in 4.1, linear_sample  (register v%d).  Opcode #%d (count is 1-based). 
renderTargetArrayIndex or viewportArrayIndex must have scalar mask in declaration.  Opcode #%d (count is 1-based). 
renderTargetArrayIndex already declared for input.  Opcode #%d (count is 1-based). 
viewportArrayIndex already declared for input.  Opcode #%d (count is 1-based). 
Interpolation mode for PS renderTargetArrayIndex or viewportArrayIndex must be constant (register v%d).  Opcode #%d (count is 1-based). 
PS output depth already declared.  Opcode #%d (count is 1-based). 
PS output depth already declared.  The previous declaration was of a different type.  Opcode #%d (count is 1-based). 
PS output coverage mask already declared.  Opcode #%d (count is 1-based). 
PS ouputs must be declared in slots less than UAVs.  Output declared in slot %d while UAV declared in slot %d.  Opcode #%d (count is 1-based). 
Components of output declaration for register o%d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
Components of output declaration for register %d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
primitiveID already declared for output.  Opcode #%d (count is 1-based). 
isFrontFace already declared for output.  Opcode #%d (count is 1-based). 
finalQuadUeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadVeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadUeq1EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadVeq1EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadUInsideTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadVInsideTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriUeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriVeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriWeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriInsideTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalLineDetailTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalLineDensityTessFactor already declared for output.  Opcode #%d (count is 1-based). 
position declaration must have xyzw mask.  Opcode #%d (count is 1-based). 
position already declared for output.  Opcode #%d (count is 1-based). 
renderTargetArrayIndex already declared for output.  Opcode #%d (count is 1-based). 
viewportArrayIndex already declared for output.  Opcode #%d (count is 1-based). 
Global flags already declared once.  Opcode #%d (count is 1-based). 
Unrecognized global flags.  Opcode #%d (count is 1-based). 
enableRawAndStructuredBuffers global flag can't be used (not needed) with Compute Shaders.  Opcode #%d (count is 1-based). 
When streams are declared, you must use emit_stream, cut_stream, and emitthencut_stream instead of emit, cut, and emitthencut.  Opcode #%d (count is 1-based). 
Input control point count must be [%d..%d].  %d specified.  Opcode #%d (count is 1-based). 
Hull Shader input control point count already declared. Aborting.  Opcode #%d (count is 1-based). 
Input control point count must be [0..%d].  %d specified.  Opcode #%d (count is 1-based). 
Domain Shader input control point count already declared. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader output control point count already declared. Aborting.  Opcode #%d (count is 1-based). 
Output control point count must be [0..%d].  %d specified.  Opcode #%d (count is 1-based). 
Invalid Tessellator Domain specified. Must be isoline, tri or quad. Aborting. Opcode #%d (count is 1-based). 
Tessellator domain already declared. Aborting. Opcode #%d (count is 1-based). 
Invalid Tessellator Partitioning specified. Must be integer, pow2, fractional_odd or fractional_even. Aborting. Opcode #%d (count is 1-based). 
Tessellator Partitioning already declared. Aborting. Opcode #%d (count is 1-based). 
Invalid Tessellator Output Primitive specified. Must be point, line, triangleCW or triangleCCW. Aborting. Opcode #%d (count is 1-based). 
Tessellator Output Primitive already declared. Aborting. Opcode #%d (count is 1-based). 
Hull Shader output max tessfactor already declared. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader MaxTessFactor must be [%f..%f].  %f specified.  Opcode #%d (count is 1-based). 
Hull Shader Fork Phase Instance Count already declared in this phase. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader Fork Phase Instance Count must be [%d..%d].  %d specified.  Opcode #%d (count is 1-based). 
Hull Shader Join Phase Instance Count already declared in this phase. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader Join Phase Instance Count must be [%d..%d].  %d specified.  Opcode #%d (count is 1-based). 
Declared Thread Group X size %d outside valid range [%d..%d].  Opcode #%d (count is 1-based). 
Declared Thread Group Y size %d outside valid range [%d..%d].  Opcode #%d (count is 1-based). 
Declared Thread Group Z size %d outside valid range [%d..%d].  Opcode #%d (count is 1-based). 
Declared Thread Group Count %d (X*Y*Z) is beyond the valid maximum of %d.  Opcode #%d (count is 1-based). 
Declared Thread Group X size %d outside valid range [%d..%d] for Compute Shader version < 5_0.  Opcode #%d (count is 1-based). 
Declared Thread Group Y size %d outside valid range [%d..%d] for Compute Shader version < 5_0.  Opcode #%d (count is 1-based). 
Declared Thread Group Count %d (X*Y*Z) is beyond the valid maximum of %d for Compute Shader version < 5_0.  Opcode #%d (count is 1-based). 
SRV reference t%d must have a structure byte stride that is a multiple of 4 that is greater than 0 but no greater than %d when declared as structured (%d specified).  Opcode #%d (count is 1-based). 
UAV u%d already declared.  Opcode #%d (count is 1-based). 
UAVs must be declared in slots greater than PS outputs.  UAV declared in slot %d while output declared in slot %d.  Opcode #%d (count is 1-based). 
Texture2DMS[Array] or TextureCube[Array] resources are not supported with UAVs (Unordered Access Views). Opcode #%d (count is 1-based). 
Invalid resource dimension on resource u%d.  Opcode #%d (count is 1-based). 
Invalid resource return type on component %d of resource u%d.  Opcode #%d (count is 1-based). 
UAV reference u%d must be specified with invalid coherency flag.  Opcode #%d (count is 1-based). 
UAV reference u%d must have a structure byte stride that is a multiple of 4 that is greater than 0 but no greater than %d when declared as structured (%d specified).  Opcode #%d (count is 1-based). 
UAV reference u%d has invalid flag.  Opcode #%d (count is 1-based). 
Thread Group Shared Memory reference g%d already declared.  Opcode #%d (count is 1-based). 
Thread Group Shared Memory reference g%d byteCount (%d specified) must be a nonzero multiple of 4.  Opcode #%d (count is 1-based). 
Total Thread Group Shared Memory storage exceeded by g# declarations so far up to g%d.  Opcode #%d (count is 1-based). 
Thread Group Shared Memory reference g%d must have a structure byte stride that is a nonzero multiple of 4 when declared as structured (%d specified).  Opcode #%d (count is 1-based). 
Output index range defined from %d to %d includes output register %d that was not declared. 
Registers in an output index range cannot have system names associated with them (TessFactors are an exception).  Output register o%d has a name and is in an index range from o%d to o%d. 
The intersection of all masks on output registers in an index range cannot be empty. Index range from o%d to o%d has empty mask intersecion. 
Reference of undeclared temp r%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range on vertex axis for input v[%d][].  Input primitive type has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range on vertex axis for input v[%d][].  Input control point has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input v%s[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base %s[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base v%s[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base %s[%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range on vertex axis for input vcp[%d][].  Input control point has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input vcp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vcp[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vcp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vcp[][%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input vpc[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vpc[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vpc[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vpc[%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range on vertex axis for input vocp[%d][].  Output control points has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input vocp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vocp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vocp[][%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared output or undeclared components of output o%d.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing output register from base o[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared output or undeclared components of index range output starting at base o[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing output register from base o[%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared indexable temp x%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on x%d[size==%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of indexable temp x%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared sampler s%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared stream m%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared resource t%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, cb%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared constant buffer cb%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on cb%d[size==%d] (if size is listed as 0, it means default size is used, which is %d.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing not allowed for cb%d since it was not declared for dynamic indexing..  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared immediate constant buffer.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on immediate constant buffer [size==%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vPrimitiveID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vGSInstanceID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oDepth.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of register oDepth does mot match declaration (dcl_oDepthGE or dcl_oDepthLE).  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oDepthGE.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of register oDepthGE does mot match declaration (dcl_oDepth or dcl_oDepthLE).  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oDepthLE.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of register oDepthLE does mot match declaration (dcl_oDepth or dcl_oDepthGE).  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vCoverage.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oMask.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vCycleCounter.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vCycleCounter.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vOutputControlPointID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vForkPhaseInstanceID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vJoinPhaseInstanceID.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vInputThreadID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vInputThreadID.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vInputThreadGroupID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vInputThreadGroupID.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vInputThreadIDInGroup.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vInputThreadIDInGroup.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input vInputThreadIDInGroupFlattened.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared UAV u%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared thread group shared memory g%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on g%d[size==%d].  Opcode #%d, operand #%d (counts are 1-based). 
Index Dimension %d's relative address temp is out of range (%d specified, max allowed based on temp declaration is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Reference of undeclared components of indexable temp x%d[] within relative index of an operand.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range of indexable temp x%d[] within relative index of an operand.  Index [%d] specified, but based on the indexable temp declaration, the max index allowed is [%d].  Operand #%d of opcode #%d (counts are 1-based). Aborting.
function table (%d) already declared. Opcode #%d (count 1-based). 
interface decl references undefined function table (%d).  Opcode #%d (count 1-based).
interface decl expects a table of size %d, but table %d has %d elements.  Opcode #%d (count 1-based).
interface decl for interface index %d has different function table data than the interface metadata.  Opcode #%d (count 1-based).
interface decl declares an interface index %d that is not a base register in the interface metadata.  Opcode #%d (count 1-based).
interface decl declares an interface index %d that is not the interface metadata.  Opcode #%d (count 1-based).
interface decl declares an invalid interface index %d.  Opcode #%d (count 1-based).
interface decl declares an interface index (%d) that has already been declared.  Opcode #%d (count 1-based).
bufinfo requires resource declared as Buffer, Raw Buffer or Structured Buffer.  Opcode #%d, operand #%d (counts are 1-based). 
ld does not support raw or structured buffers.  Opcode #%d, operand #%d (counts are 1-based). 
ld requires resource declared as texture1D/2D/3D/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
ld2dms requires resource declared as texture2DMS/texture2DMSArray.  Opcode #%d, operand #%d (counts are 1-based). 
lod instruction requires sampler declared in default mode.  Opcode #%d, operand #%d (counts are 1-based). 
lod requires resource declared as texture1D/2D/3D/Cube/CubeArray/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
gather4
gather4_c
comparison
gather4_po
gather4_po_c
%s instruction requires sampler declared in %s mode.  Opcode #%d, operand #%d (counts are 1-based). 
/Cube/CubeArray
%s requires resource declared as texture2D/2DArray%s.  Opcode #%d, operand #%d (counts are 1-based). 
resinfo requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray/2DMS/2DMSArray.  Opcode #%d, operand #%d (counts are 1-based). 
sample/_l/_d instructions require sampler declared in default mode.  Opcode #%d, operand #%d (counts are 1-based). 
sample/_l/_d requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
sample_c_* instructions require sampler declared in comparison mode.  Opcode #%d, operand #%d (counts are 1-based). 
sample_c_* instructions require resource declared as texture1D/2D/Cube/1DArray/2DArray/CubeArray.  Opcode #%d, operand #%d (counts are 1-based). 
sample_c_* instructions require resource declared as texture1D/2D/Cube, but arrays not allowed.  Opcode #%d, operand #%d (counts are 1-based). 
sample_b requires sampler declared in default mode.  Opcode #%d, operand #%d (counts are 1-based). 
bias amount for sample_b must be in the range [%f,%f], but %f was specified as an immediate. Opcode #%d, operand #%d (counts are 1-based). 
sample_b requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
swapc requires destination registers to be different.  Opcode #%d, operand #1 and operand #2 (counts are 1-based).
sync in Pixel Shader must only sync UAV (sync_uglobal).Opcode #%d (counts are 1-based).
sync must include some form of memory barrier - _u (UAV) and/or _g (Thread Group Shared Memory).  Only _t (thread group sync) is optional. Opcode #%d (counts are 1-based).
sync can't specify both _ugroup and _uglobal. If both are needed, just specify _uglobal. Opcode #%d (counts are 1-based).
ld_uav_typed cannot be used on a UAV that is not declared as typed (u%d). Opcode #%d (counts are 1-based).
store_uav_typed cannot be used on a UAV that is not declared as typed (u%d). Opcode #%d (counts are 1-based).
store_uav_typed must write to all four components of the UAV. Opcode #%d (counts are 1-based).
ld_raw requires resource declared as Raw Buffer.  Opcode #%d, operand #%d (counts are 1-based). 
ld_raw cannot be used on a resource that is not declared as raw (resource index [%d]). Opcode #%d (counts are 1-based).
store_raw cannot be used on a resource that is not declared as raw (resource index [%d]). Opcode #%d (counts are 1-based).
ld_structured requires resource declared as Structured Buffer.  Opcode #%d, operand #%d (counts are 1-based). 
ld_structured cannot be used on a resource that is not declared as structured (resource index [%d]). Opcode #%d (counts are 1-based).
store_structured cannot be used on a resource that is not declared as structured (resource index [%d]). Opcode #%d (counts are 1-based).
store_structured writing to Thread Group Shared Memory for shader models less than 5_0 must use 
vThreadIDInGroupFlattened as the structure index (second) parameter. Opcode #%d (counts are 1-based).
imm_atomic_alloc and imm_atomic_consume on a given UAV (%d) cannot both be in the same shader. Opcode #%d (counts are 1-based).
imm_atomic_alloc and imm_atomic_consume can't be combined with other atomic operations on an Append UAV (%d). Opcode #%d (counts are 1-based).
imm_atomic_alloc and imm_atomic_consume require as Structured Buffer UAV (slot %d). Opcode #%d (counts are 1-based).
sample_* instructions require resource to be declared to return UNORM, SNORM or FLOAT.  Opcode #%d, operand #%d (counts are 1-based). 
vCycleCounter can only be used with the mov instruction.  Opcode #%d, operand #%d (counts are 1-based). 
else statement doesn't match to an if statement. Opcode #%d (count 1-based). Aborting validation.
else statement seen already.  Opcode #%d (count 1-based). Aborting validation.
endif statement doesn't match to an if statement. Opcode #%d (count 1-based). Aborting validation.
endloop statement doesn't match to a loop statement. Opcode #%d (count 1-based). Aborting validation.
endswitch statement doesn't match to a switch statement. Opcode #%d (count 1-based). Aborting validation.
case statement doesn't match to the scope of a switch statement. Opcode #%d (count 1-based). Aborting validation.
case %d (or if bits to be interpreted as float: %f) already seen. Opcode #%d (count 1-based).
default statement doesn't match to the scope of a switch statement. Opcode #%d (count 1-based). Aborting validation.
default statement seen already.  Opcode #%d (count 1-based).
continue/continuec statement not inside loop.  Opcode #%d (count 1-based).
break/breakc statement not inside loop or switch.  Opcode #%d (count 1-based).
call/callc statement not referencing a label.  Opcode #%d (count 1-based).
Shader Model 5+ requires that subroutine definitions appear after any call(s) to the subroutine. This also implies recursion is not allowed, although that may or may not be the case here.  Aborting. Opcode #%d (count 1-based).
Multiple Hull Shader phases cannot call the same subroutine. If this is an important feature, support could be considered in the future. Opcode #%d (count is 1-based)
fcall statement not referencing an interface.  Opcode #%d (count 1-based).
fcall statement referencing an undeclared interface (%d).  Opcode #%d (count 1-based).
fcall statement referencing an out of bounds function index (%d).  Opcode #%d (count 1-based).
Shader exceeds maximum supported number of interface call sites (%d).  Opcode #%d (count 1-based).
Multiple Hull Shader phases cannot call the same interface body. If this is an important feature, support could be considered in the future. Opcode #%d (count is 1-based)
label (%d) being defined without any callers. Shader Model 5+ requires all callers to a subroutine to appear before the subroutine definition. Aborting.Opcode #%d (count 1-based). 
label (%d) was never used in the shader
label (%d) must be preceded by a ret. Opcode #%d (count 1-based). Aborting validation.
label (%d) must not be nested inside flow control. Opcode #%d (count 1-based). Aborting validation.
Interpolation mode on input v# register used with eval_* instruction must be linear, linear_centroid, linear_noperspective, linear_noperspective_centroid, linear_sample or linear_noperspective_sample. Opcode #%d (count is 1-based). 
It is invalid to use eval_* on position input due to hardware limitation.  Opcode #%d (count is 1-based). 
Can't fall through case/default unless case/default has no code. Opcode #%d (count 1-based). Aborting validation.
switch must be followed by case or default. Opcode #%d (count 1-based). Aborting validation.
ret can only be followed by case/default/endswitch/endloop/else/endif/label. Opcode #%d (count 1-based). Aborting validation.
break/continue can only be followed by case/default/endswitch/endloop/else/endif. Opcode #%d (count 1-based). Aborting validation.
label (%d) called but not defined.
label (%d) defined but never called.
End of program reached with incomplete flow control structure.
When code ends in subroutine definition, it must end with ret.
%s signature parameter %s (1-based Entry %d) specifies invalid interpolation mode for integer component type. 
%s signature parameter %s (1-based Entry %d) specifies unrecognized or invalid component type. 
%s array signature parameter %s cannot be indexed dynamically.
Non system-generated input signature parameter (%s) cannot appear after a system generated value.
%s signature parameter %s (1-based Entry %d) type must be float32. 
%s signature parameter %s (1-based Entry %d) type must be uint32. 
%s signature parameter %s (1-based Entry %d) type must be float32 and mask must be xyzw. 
Too many %s signature parameters of type SV_ClipDistance or SV_CullDistance.  Maximum number of registers usable is %i.
%s signature parameter %s (1-based Entry %d) type must be a scalar uint. 
%s signature parameter %s (1-based Entry %d) type must be a scalar float. 
%s signature parameter %s (1-based Entry %d) has an unrecognized system name. 
Stream index (%u) must between 0 and %u.
Patch constant signature parameter #%d (1-based) specifies out of range register %d. 
Patch constant signature parameter #%d (1-based) specifies register %d (or components in the register) that have already been defined. 
Patch constant signature name mismatch with declaration in shader code for component %d in register %d. 
Patch constant signature signature does not specify component %d of register %d which is declared in the shader code. 
Input signature parameter #%d (1-based) specifies out of range register %d. 
Input signature parameter #%d (1-based) specifies register %d (or components in the register) that have already been defined. 
Input signature name mismatch with declaration in shader code for component %d in register %d. 
Input signature does not specify component %d of register %d which is declared in the shader code. 
Output signature parameter #%d (1-based) specifies out of range register %d. 
Output signature parameter #%d (1-based) specifies register %d (or components in the register) that have already been defined. 
Output signature name mismatch with declaration in shader code for component %d in register %d. 
Output signature does not specify component %d of register %d which is declared in the shader code. 
Pixel Shader allows output semantics to be SV_Target, SV_Depth, SV_DepthGreaterEqual, SV_DepthLessEqual or SV_Coverage only.  Output signature parameter #%d (1-based) specifies semantic %s. 
Double operations not supported unless globalFlags includes enableDoublePrecisionFloatOps.
Unrecognized instruction or instruction not valid in vertex shader.
Hull Shader declsphase must declare an input control point count.
Hull Shader declsphase must declare an output control point count.
Hull Shader declsphase must declare a tessellator domain.
Hull Shader declsphase must declare a tessellator partitioning.
Hull Shader declsphase must declare a tessellator output primitive.
Hull Shader declared with IsoLine Domain must specify output primitive point or line. triangle_cw or triangle_ccw output are not compatible with the IsoLine Domain.
Hull Shader declared with Tri Domain must specify output primitive point, triangle_cw or triangle_ccw. line output is not compatible with the Tri domain.
Hull Shader declared with Quad Domain must specify output primitive point, triangle_cw or triangle_ccw. line output is not compatible with the Quad domain.
All HS control point phase input v[][] registers must have control point count (first dimension) declared with size less than or equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
Total number of scalars across all HS output control points must not exceed %d. Current output control point declaration specifies %d scalars of output per control point with %d output control points, resulting in %d total scalars of output control point data. 
All HS fork phase input vcp[][] registers must have control point count (first dimension) declared with size less than or equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
All HS fork phase input vocp[][] registers must have control point count (first dimension) declared with size less than or equal to the number of output control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
Hull Shader Fork Phase reads component(s) of output control point [%d] which were not output by the Control Point Phase.
Multiple fork phase programs declared the same component(s) of output patch constant register o[#d].
Multiple fork phase programs cannot declare partially overlapping index ranges for output Patch Constant Data. One index range is from register [%d] to [%d], while the another is from [%d] to [%d].
All HS join phase input vcp[][] registers must have control point count (first dimension) declared with size equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
All HS join phase input vocp[][] registers must have control point count (first dimension) declared with size equal to the number of output control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
Hull Shader Join Phase reads component(s) of output control point [%d] which were not output by the Control Point Phase.
Join phase declaring component(s) of input patch constant register vpc[%d] which have not been output by previous fork phase(s) or other join phase(s).
Join phase declared the same component(s) of output patch constant register o[#d] as already declared for output by a previous fork phase or other joint phase.
Multiple fork/join phase programs cannot declare partially overlapping index ranges for output Patch Constant Data. One index range is from register [%d] to [%d], while the another is from [%d] to [%d].
When the Hull Shader doesn't have a Control Point Phase, the declared Input Control Point Count (%d) must match the declared Output Control Point Count (%d), indicating the control points will pass through, or the Output Control Point Count can be set 0. 
Related TessFactor names (such as edges) must be declared in the same component of consecutive Patch Constant registers, in the correct order. %s is in %s[%d].%s, which would put %s past the end of the available registers, since it is %d name after %s in the order.
Related TessFactor names (such as edges) must be declared in the same component of consecutive Patch Constant registers, in the correct order. %s expected in %s[%d].%s since %s is in %s[%d].%s.
ISOLINE
Required TessFactor name %s for %s domain not found declared anywhere in Patch Constant data. 
Index ranges declared on Patch Constant Data cannot cross over related blocks of hardware TessFactors. An index range is declared from register [%d] to [%d], which crosses over a block of TessFactors that starts with %s in register [%d] and ends in %s in register [%d].
Unrecognized instruction or instruction not valid in Hull Shader.
Hull Shader must start with HSDecls phase.
Invalid instruction for Hull Shader Decls phase.
Declaration statements in HS Control Point phase must appear before other instructions.
Invalid instruction for Hull Shader Control Point phase.
Declaration statements in HS Fork phase must appear before other instructions.
Invalid instruction for Hull Shader Fork phase.
Declaration statements in HS Join phase must appear before other instructions.
Invalid instruction for Hull Shader Join phase.
Invalid instruction for Hull Shader postamble section (subroutines and function bodies).
Unrecognized instruction or instruction not valid in Domain Shader.
Unrecognized instruction or instruction not valid in geometry shader.
Declared output vertex count (%d) multiplied by the total number of declared scalar components of output data (%d) equals %d.  This value cannot be greater than %d.
Unrecognized instruction or instruction not valid in pixel shader.
Dest register relative index temp register component %d in r%d uninitialized. Opcode #%d (count is 1-based)
Dest register relative index indexable-temp register component %d in x[%d][%d] uninitialized. Opcode #%d (count is 1-based)
source register relative index temp register component %d in r%d uninitialized. Opcode #%d (count is 1-based)
source register relative index indexable-temp register component %d in x[%d][%d] uninitialized. Opcode #%d (count is 1-based)
source component %d in temp r%d not initialized. Opcode #%d (count is 1-based)
source indexable temp register component %d in x%d[*] never initialized anywhere.Opcode #%d (count is 1-based)
Instructions calculating derivatives across pixels, and using temp storage or indexed values for input coordinates, are not permitted within flow control that has a branch condition that could vary across pixels. Opcode %d (count is 1-based).
Unrecognized instruction or instruction not valid in Compute Shader.
firstbit_shi
firstbit_hi
eval_centroid
eval_snapped
resinfo
bufinfo
sampleinfo
samplepos
atomic_and
atomic_or
atomic_xor
atomic_iadd
atomic_imax
atomic_imin
atomic_umax
atomic_umin
atomic_cmp_store
imm_atomic_and
imm_atomic_or
imm_atomic_xor
imm_atomic_iadd
imm_atomic_imax
imm_atomic_imin
imm_atomic_umax
imm_atomic_umin
imm_atomic_exch
imm_atomic_cmp_exch
imm_atomic_alloc
imm_atomic_consume
D3DX: (WARN) Overloaded ::new and ::delete operators do not conform to C++ standards:
D3DX: (WARN) An allocation of zero bytes should return a unique non-null pointer to at
D3DX: (WARN) least zero bytes. Deletion of a null pointer should quietly do nothing.
D3DX: (WARN) D3DX11 relies upon this behavior.
cabinet.dll
FCICreate
FCIAddFile
FCIFlushCabinet
FCIDestroy
FDICreate
FDICopy
FDIDestroy
D0x%I64x
continuec
emit_then_cut
endswitch
deriv_rtx
deriv_rty
round_ne
round_ni
round_pi
round_z
sample_b
sample_l
sample_d
sample_c
sample_c_lz
dcl_input
dcl_output
dcl_input_sgv
dcl_input_ps_sgv
dcl_inputprimitive
dcl_outputtopology
dcl_maxout
dcl_input_ps
dcl_constantbuffer
dcl_sampler
dcl_resource
dcl_input_siv
dcl_input_ps_siv
dcl_output_siv
dcl_output_sgv
dcl_temps
dcl_indexableTemp
dcl_indexrange
dcl_globalFlags
emit_stream
cut_stream
emit_then_cut_stream
dcl_stream
dcl_function_body
dcl_function_table
dcl_interface
deriv_rtx_coarse
deriv_rtx_fine
deriv_rty_coarse
deriv_rty_fine
firstbit_lo
hs_decls
hs_control_point_phase
hs_fork_phase
hs_join_phase
dcl_input_control_point_count
dcl_output_control_point_count
dcl_tessellator_domain
dcl_tessellator_partitioning
dcl_tessellator_output_primitive
dcl_hs_max_tessfactor
dcl_hs_fork_phase_instance_count
dcl_hs_join_phase_instance_count
dcl_thread_group
dcl_uav_typed
dcl_uav_raw
dcl_uav_structured
dcl_tgsm_raw
dcl_tgsm_structured
dcl_resource_raw
dcl_resource_structured
ld_uav_typed
store_uav_typed
store_raw
ld_structured
store_structured
eval_sample_index
dcl_gsinstances
debug_break
vs_4_0_level_9_0
vs_4_0_level_9_3
vs_4_0_level_9_1
vs.3.sw
vs.2.sw
ps_4_0_level_9_0
ps_4_0_level_9_3
ps_4_0_level_9_1
ps.3.sw
ps.2.sw
</font>
<font color = "#
<font color = "#%s">
D3DCompiler_43.pdb
UVWATAUAVAWH
A_A^A]A\_^]
@USVWAUAVAWH
A_A^A]_^[]
@SUVWATH
mHI;,$t}H
USVWAUI
|$`9Y,t
\$|D9|$d
\$|D;|$d
OSGNu5H
L$H;D$@s
PERFu<A
t3fffff
@USVAVH
@SATAUH
|$ ATE3
@USVWATAUAVAWH
T$Xffffff
A_A^A]A\_^[]
|$ ATAUAVH
 A^A]A\
@UVWATAUH
@A]A\_^]
WATAUAVAWH
PA_A^A]A\_
@SUVWAWH
@A__^][
UWATAUH
D9s4t,H
D9s,t%H
7D9s,t%H
D9s4t,H
C0L9s@u
UVWATAUAVAWH
uVIc@`H
u+Ic@`H
A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
@SUVATAWH
tY9p(uTH
0A_A\^][
H9p@t!H
StH9w@t!H
H9p@t!H
0A_A\^][
@USATAUAWH
pA_A]A\[]
@UATAUAVAWH
A_A^A]A\]
fffffff
H9}xt&H
C<H9O@t
D$PSDBG
D$@SHEX
D$DSHDR
\$@9\$\
\$@;\$\
UVWATAUAVAWH
fffffff
A_A^A]A\_^]
SVATAUH
|$pfD9f
t$hfD9f
fD;f sIL
xA]A\^[
USVWAWH
`A__^[]
EH    u
`A__^[]
WATAUAVAWH
A_A^A]A\_
L$ SVWAUAWH
`A_A]_^[
t(fffff
VWATAUAWH
rjH;L$`scH
pA_A]A\_^
>TEXTugA
t"ffffff
@WATAUAVH
A;B4r7H
A^A]A\_
SUVWAVAWH
XA_A^_^][
                      
                     
       
                        
        
                       
                           
               
UVWATAUH
H9D$8sDf
D$HH9D$8r
A]A\_^]
D$HA9,$
d$ UAUAVH
@UATAVH
@UVWATAVAWH
A_A^A\_^]
L$ SVWAUAWH
pA_A]_^[
\$ UVWH
UVATAUAVH
0A^A]A\^]
UVWATAUAVAWH
@A_A^A]A\_^]
UVWATAUAVAWH
D$@@8(t
A_A^A]A\_^]
L$ SVATAVH
xA^A\^[
\$ ATAUAVH
0A^A]A\
UVWATAUAVAWH
A_A^A]A\_^]
l$ VATAUH
VWATAUAVH
0A^A]A\_^
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
PA_A^A]A\_^]
UVWATAUH
PA]A\_^]
WATAUAVAWH
@A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
UVAUAVAWH
 A_A^A]^]
VWATAUAVH
0A^A]A\_^
UVWATAUAVAWH
@A_A^A]A\_^]
@UVAVAWH
8A_A^^]
@UATAUAWH
A_A]A\]
t$ WATAUAVAWH
 A_A^A]A\_
@VWATAVAWH
 A_A^A\_^
x&fffffff
 A_A^A\_^
@SUVAVAWH
 A_A^^][
@SVAUAWH
8A_A]^[
@WAUAVAWH
(A_A^A]_
SVWAUAVH
|7(	u6L
`A^A]_^[
UVWATAUAVAWH
A9w$u$A9w<u
 A_A^A]A\_^]
|$ ATAUAVH
 A^A]A\
UVWATAUAVAWH
`A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
\$ UVWATAUAVAWH
T$`;L$X
\$Pffff
A_A^A]A\_^]
9\$<vDf
|$ UATAUAVAWH
A_A^A]A\]
|$ UATAUAVAWH
A_A^A]A\]
@USVWAUAVAWH
A_A^A]_^[]
UVWATAUAVAWH
D$@H9hHt
pA_A^A]A\_^]
9j8u,H9j@t&H9jHu I
{ UATAUAVAWH
u!D9}<@
D9z8u0L9z@t*L9zHu$H
A_A^A]A\]
A9Q4v'3
@USWATAUH
A]A\_[]
A9T$8u>I9T$@t7I9T$Hu0L
@SUWATAUAVAWH
A_A^A]A\_][
@USVWATAUAVAWH
xsM9>uG
xA_A^A]A\_^[]
@SUVAUAVH
x>9\$<v8H
`A^A]^][
@SUWATAUH
l$0L9+uG
@A]A\_][
@USWATAUAVAWH
A_A^A]A\_[]
@UVWAUAVH
pA^A]_^]
SUVWATAUAWH
@A_A]A\_^][
UVWATAUAVAWH
V$A;V r
fffffff
A_A^A]A\_^]
D$@;B4u
B 9A t[
UVWATAUAVAWH
A_A^A]A\_^]
wHH9wXt1ff
wHH9wPt/
H9qXt-f
9X8v;fff
D$@H9x8
A8HcD$4
UVWATAUAVAWH
 A_A^A]A\_^]
tjfffff
D$0H9x8uXH9x
USVWATAUAVAWH
A_A^A]A\_^[]
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
t-ffffff
@A_A^A]A\_^]
uwffffff
UVWATAUAVAWH
H9GPt	H
A_A^A]A\_^]
D9T$huYE;
uBD9L$`u;D;
uCD9L$`u<A
UATAUAVAWH
A_A^A]A\]
@WATAUH
WATAUAVAWH
pA_A^A]A\_
@SUVWATH
PA\_^][
ApXNAPD
HcT$dE3
D$@9]8vx3
t$ WATAUH
SUATAUH
t#ffffff
UUUUUUU
D9t$pv;H
	fffffff
SUVWAVH
@A^_^][
tFfffff
|$ ATAUAVE
|$ ATAUA
t8fffff
|$ ATAUAVH
tcL9R(u:H
E9_0r_@
L9R(u>H
M9P(u$I
UVWATAUAVAWH
H9Z(u>H
A_A^A]A\_^]
|$ ATAUAVAWH
A_A^A]A\
@SVAUAVAWH
 A_A^A]^[
8\$Pt&H
l$@8\$Pt.H
\$ UWATH
@VATAUAVAWH
`A_A^A]A\^
s WATAUAVAWH
D;m rSH
A_A^A]A\_
A9H v03
@SUVWATH
@A\_^][
fD9k|tP
fD9k~tP
t:ffffff
SWAUAVH
@UATAUAVAWH
T$ fffff
@A_A^A]A\]
@USVATAWH
A_A\^[]
UWAUAVH
HA^A]_]
T$`;D$Xs%L
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
UVWATAUAVAWH
0A_A^A]A\_^]
@USVATH
WATAUAVAWH
 A_A^A]A\_
E9H0w5A
@USATAVH
SVAUAVH
0Hcl$pI
@SWAUAWH
XA_A]_[
@USWAVH
t=ffffff
SUVWATAUH
HA]A\_^][
l$ VWATAUAVAWE3
T$@fffff
A_A^A]A\_^
SUVWATAUAVAWH
A_A^A]A\_^][
SUWATAVH
@A^A\_][
@USVWATAUAVAWH
HA_A^A]A\_^[]
t$HD9O vlE3
@SUVWATAUAVAWH
HA_A^A]A\_^][
d$@fffff
t$Hffff
E9eLvfM
D$`DBUGH
UUUUUUU
u%;PHu 
l$ VWATH
UVWATAWH
0A_A\_^]
l$ VWATH
L$ WATAUAVAWH
 A_A^A]A\_
SUVWATAUAVAWH
D$TA;G(u%
A_A^A]A\_^][
WATAUAVAWD
A_A^A]A\_
|$ ATAUAVH
 A^A]A\
\$ UVWATAUAVAWH
A_A^A]A\_^]
																			
UVWATAUAVAWH
E0D;t$\
L9e(t!H
eDD8eHt>H
A_A^A]A\_^]
SUVWAUAVAWH
0A_A^A]_^][
t$ ATAUAVH
0A^A]A\
UUUUUUU
L$(fffff
fD9c|tP
fD9c~tP
D$xffff
T$`E;n u;E;
V D;d$p
D$l;D$h
@UWATAUH
\$0@8|$0t+
hA]A\_]
T$`E;w u:A
P!w>t_=
d$hffffff
fffffff
@UWATAUH
\$0@8|$0t/
hA]A\_]
@WAUAWH
``wdt1=
 `w4tO=
Pbw,t =
UVWATAUAVAWH
0A_A^A]A\_^]
]38]7t/H
]K8]Ot*H
SUVWATAUAVAWH
XA_A^A]A\_^][
\$ fffffff
H9q0t-H
D9N v)A
\$H;l$@
9k$vS;k$s
@UATAUAVAWH
0A_A^A]A\]
\$ UATAUH
t$ WATAUAVAWH
|$PD;q$s
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
C0A;BTs
\$ UATAUH
s4;t$Hv 
@USVAUAVAWH
u/A9t$4
A;\$4uoD
tnA8t$,tgI
t2A8t$-t+A;
t2A8t$.t+A;
A8t$	t&A;
@8t$Pt.H
A_A^A]^[]
9p<v	D;
@SVAUAVAWH
T$0D9h<t
PA_A^A]^[
VWATAUAVH
A^A]A\_^
UVWATAUAVAWH
A_A^A]A\_^]
@USVWATAUAVH
A^A]A\_^[]
@SUVWATH
D9b vZM
Pgw)tC=
t^ffffff
UVWATAUAVAWH
@A_A^A]A\_^]
@USVAUH
@USVWATH
\$ UVWATAUH
A]A\_^]
VWATAUAVH
A^A]A\_^
|$ UATAUAVAWH
A_A^A]A\]
A9S vtM
WATAUAVAWH
`!w~tj=
 Rw<t =
Pawmt =
@hw=tt=
0A_A^A]A\_
@SVATAUH
hA]A\^[
UVWATAUAVAWH
 A_A^A]A\_^]
l$ VWATH
WATAUAVAWH
 A_A^A]A\_
|$ ATAUAVAWE3
|$@A_A^A]A\
H9\$ uRA
H9D$ uP
|$ UATAUAVAWH
A_A^A]A\]
UUUUUUU
|$ ATAUAVH
 A^A]A\
|$ ATAUAVH
 A^A]A\
D9A v$E
tCffffff
fffffff
t^fffff
@SUWAUAVAWH
hA_A^A]_][
t*ffffff
0PwTtE=
@VATAUH
@USVWATAVAWH
`A_A^A\_^[]
SUVATAWH
fffffff
 A_A\^][
fffffff
t$ WATAUH
UVWATAWH
fffffff
 A_A\_^]
\$ UVATAVAWH
A_A^A\^]
|$ ATAUAVH
l$ VWATAVAWH
A_A^A\_^
l$ WATAVH
I9Y0t-I
B;T @uP
fD9k|tP
fD9k~tP
'ffffff
vOD8l$huHH
D$ ;L$h
L9y0t-H
tHL9|$Pu
D;k sPH
fD9{|tO
fD9{~tO
fD9{~tP
tMfffff
tjffffff
t*ffffff
UVWATAUH
PA]A\_^]
@USVWATAUAVAWH
A9p v H
A_A^A]A\_^[]
D9c8vSH
D9cLv'I
D9cxv/I
\$ VWATH
D$4L9#uH
\$ UVATH
D$4L9#uG
L$ A9Hx
T$(A;Hx
T$PA;N8
T$0D;A$
D9BLv%I
D9Bxv-M
y(9Q$v+
{H9SLv.H
{d9S`v.H
d$89Sxv=L
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
<8PERFt
<0PERFt
<8SDTLt
<0SDTLt
<0SMIDt
<0SDBGt
<0STATt
<8RDEFt
<8ISGNt
<8OSGNt
UVWATAUAVAWH
A_A^A]A\_^]
@USWAWH
VATAUAVAWH
`A_A^A]A\^
SUAUAVAWH
@A_A^A]][
<stS<ttO<utKH
tLHcT$xD
D$pHcH 3
WATAUAVAWH
A_A^A]A\_
AUAVAWH
@A_A^A]
$0< u	I
$0< u	H
UVWATAUAVAWH
$0< u	I
PA_A^A]A\_^]
9|$(tM2
|$ ATAUAVH
WATAUAVAWH
 A_A^A]A\_
VWATAUAVH
0A^A]A\_^
@SUVWATAUAVAWH
A_A^A]A\_^][
L$ UVWATAUAVAWH
A_A^A]A\_^]
VWAUAVAWH
A_A^A]_^
UVWATAUAVAWH
`A_A^A]A\_^]
USVWAUAWH
A_A]_^[]
0Ru4I9Y
UVWATAUAVAWH
PA_A^A]A\_^]
UVWATAUAVAWH
`A_A^A]A\_^]
UVWATAUH
PA]A\_^]
SUVWATAUAVAWH
8A_A^A]A\_^][
l$ VAUAVH
k VWATH
@SUWATAUAVAWH
PA_A^A]A\_][
WATAUAVAWH
A_A^A]A\_
l$ VATAU
u$fffffff
l$8A]A\^
|$ UATAUH
L$`H;L$ht
\$ UWATAUAVH
`A^A]A\_]
WATAUAVAWH
 A_A^A]A\_
@UATAUAVA
A^A]A\]
|$@A^A]A\]
t$8A]A\]
USVWATH
pA\_^[]
l$ VWATH
D$XH9D$P
D$XH9D$Pu*
|$ ATAUAVH
0A^A]A\
D9X8v;E3
UVWATAUAVAWH
pA_A^A]A\_^]
@SUVWATAUAVAWH
A_A^A]A\_^][
\$ UVWH
@SUVWATAUAVAWH
A_A^A]A\_^][
VWATAUAVH
A^A]A\_^
@VATAUH
l$ VWAUAVAWH
 A_A^A]_^
@SUVAVH
E8<$t	H
UWATAUAWH
0A_A]A\_]
t0D8:t+H
0A_A]A\_]
K`H9O0t9H
KPH9O(t9H
B(9A(u:H
CXH9O0t9H
C`H9O@t
Y(D;Z(ut
B@9A@ul
BD9ADudH
A0H;B0u
A8H;B8u
@0A9A0u9I
@8I9A8u/I
KhH9O@t9H
C`I9B`u
VWATAUAVH
t%M9rpt<E3
0A^A]A\_^
@USWATH
UVWATAUAVAWH
@A_A^A]A\_^]
D8l$pu>H;
UWATAUAVH
0A^A]A\_]
t$ ATAUAVH
 A^A]A\
t$ WATAUAVAWH
H`H9Nhu
0A_A^A]A\_
L$ SAUAVAWH
8A_A^A][
H9qht}H
CH9GHu"L
L$ SUVATAVAWH
uBD8}Pt
hA_A^A\^][
SUVWATAVAWH
`A_A^A\_^][
SVATAWH
v+@8q!u
HA_A\^[
VWATAUAVH
 A^A]A\_^
twfffffff
VWATAUAVH
FhI9E8u-M
0A^A]A\_^
@SUVWAVH
D$`9G@r
D9D$xue
UVWATAUAVAWH
`A_A^A]A\_^]
UVWATAUAVAWH
H9y8tnH
twL9{`tqE
PA_A^A]A\_^]
H9y8t!H
WATAUAVAWH
0A_A^A]A\_
D$@9L$0r
@USVWATAUAWH
A_A]A\_^[]
hXH9i8t
B09A0uCH
C@H9G@u
l$ VATAUH
@SUWAUH
@UVATAUH
hA]A\^]
hXH9i0t
@SVAUAVH
(A^A]^[
|$ ATAUAVH
 A^A]A\
F0H	C(H
F0H	C H
F0H	C0H
B0H9A0u
SdHcD$$L
|$ ATAUAVH
fffffff
 A^A]A\
|$ ATAUAVH
 A^A]A\
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
u4D9c0u.H
H9S8u H
A_A^A]A\_^]
I9U@u6I
SUVWAUAWH
(A_A]_^][
I9L$@u.I
F8I9F0t
D$8I9D$0t	I
UVATAUAWH
@A_A]A\^]
@0H9A0~
@8H9A8}
B(I3@(H#
B8I9B0t
UWATAUAVH
0A^A]A\_]
WATAUAVAWH
0A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
SWATAUAWH
L$hffff
A_A]A\_[
L$ SUVWAUH
@A]_^][
fffffff
@A]_^][
D$lD8|$tt%A
A9QLv%I
L9|$Xt(I
UWATAUAWH
A_A]A\_]
@SUATAUAVAWH
A_A^A]A\][
SUVATAUAVAWH
fffffff
A_A^A]A\^][
USVATAUAVAWH
A_A^A]A\^[]
{ ATAUAVH
x,D9t$Dv%H
uBH9X0w<D;
B4A9C4wh3
WATAUAVAWH
A_A^A]A\_
\$ UATA
SUVWATAWH
A_A\_^][
@Pwit}E
`hw"tEA
@PwdtxE
`hw"tCA
UVWATAUAVAWH
 A_A^A]A\_^]
UVWATAUAVH
A^A]A\_^]
l$ VWAUAVAWH
A_A^A]_^
USVWAVAWH
A_A^_^[]
UVWATAUAVAWH
<stE<ttA<ut=H
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
USVWATAUAVAWH
D$pD9D$|
A_A^A]A\_^[]
C@9{LvmI
UVWATAUAVAWH
pA_A^A]A\_^]
t$ WATAUAVAWH
t;ffffff
A_A^A]A\_
l$ ATAUAVI
SUVWATAUAVAWH
A_A^A]A\_^][
u!8T$Qu
|$ ATAUAVH
@(H9G(uqH
urLcT$PH
U@;D$Xs
D$P9D$Xv
EXfffffff
E(H;Ehr
SUAUAWH
H)D$`L+
UVWAUAVH
A^A]_^]
UVWATAUAVAWH
A_A^A]A\_^]
|$ UATAUAVAWH
A_A^A]A\]
t$ WATAUH
USVWATAUAWH
A_A]A\_^[]
VWATAUAVH
 A^A]A\_^
D$h8D$`tu@
UVWATAUAVAWH
0A_A^A]A\_^]
SVWAVAWH
A_A^_^[
SVWATAVH
H9L$0tO
`A^A\_^[
|$ ffff
L$ USWH
9|$pvUL
@USWAUAWH
A_A]_[]
D$PH9D$Xu
E,8E0t'H
@SWAUAVH
8A^A]_[
ATAUAVH
 A^A]A\
t$ WATAUAVAWH
 A_A^A]A\_
@0D;A0ukH
l$ VWAVH
l$PD;qLs
9YLvzffff
UVATAUH
I9(uKA;
XA]A\^]
d$,D8d$0t
USVWATAUAVAWH
d$hD;gLs	D
D$x;FLs
A_A^A]A\_^[]
UVWATAUAVAWH
D9^Lu	D9
A_A^A]A\_^]
|$ UATAUAVAWH
A_A^A]A\]
L$ UVWAUAVAWH
A_A^A]_^]
L$ USVWATAUAVAWH
uX8D$`t^
@09A0w2H
@8I9@0t
fffffff
A_A^A]A\_^[]
USVWATAUAVAWH
A_A^A]A\_^[]
|$ ATAUAVH
VATAUAVAWH
A_A^A]A\^
@USWATAVH
fffffff
A^A\_[]
 !"#$%&'()*+,-./0123456789:;<=>?
@ABCDEFGGGHIIHIIJKLMNNNONNNNNNPQRSTUVWXYZ[\]^_`abcdefghijklmnop
USVWATAUAVAWH
A_A^A]A\_^[]
USVWATAUAVAWH
A_A^A]A\_^[]
@UVWATAUAVAWH
yTH9\$`HcD$pD
A_A^A]A\_^]
SUVWATAUAVAWH
A_A^A]A\_^][
UVWATAUAVAWH
A_A^A]A\_^]
SUVWATAUH
xA]A\_^][
ss !"# $%&'$%&'$()*+(,-./,-./,0123ss4456789:ss;<=>;?@AB?@AB?CDEFCGHIJGHIJGKLMNssOPQRssSTUsssVsWsXsYsssZ[\]Zsssss^_`a^sssssbcdsssesfsgshsssijklisssssmnopmsssssqr
SVWAUAVH
A^A]_^[
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
`A_A^A]A\_^]
|$ UATAUAVAWH
A_A^A]A\]
UVWATAWH
A_A\_^]
@SWAVAWH
HA_A^_[
uFD9cLu
u5D9cLt/
L$hIcA8
A4D;B4wuE3
x0;|$`w
D9T$(v*H
D$HH3D$X
D$HH#D$X
u<8\$ t6E3
@VATAUH
:::::::::::::::
: !":#$:%%%&''&'':():::::::::::*::::::+,:-./01:2345::::::::::67:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::8:9
|$ ATAUAVH
 A^A]A\
VWATAUAVH
0A^A]A\_^
WATAUAVAWH
@A_A^A]A\_
t$ WATAUAVAWH
0A_A^A]A\_
VWATAUAVH
A^A]A\_^
UVWAVAWH
A_A^_^]
UVATAUAVH
A^A]A\^]
UVWAUAVH
0A^A]_^]
@SVATAUH
(A]A\^[
SUWATAUH
A]A\_][
u8D9@8uaH
USVWATAUAWH
A_A]A\_^[]
|$ ATAUAVH
FhH9E8u
C0H;nht
0A^A]A\
|$ ATAUAVH
FhH9E8u
C0H;nht
0A^A]A\
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAVH
@A^A\_^]
@UVAUAWH
|$pffff
8A_A]^]
@SUVWATAUAVAWH
A_A^A]A\_^][
H SVWATAUAVAWH
A_A^A]A\_^[
@SUVATAUAVAWH
A_A^A]A\^][
@SUVWATAUAVAWH
A_A^A]A\_^][
u:@8uPt
UVWAUAWH
PA_A]_^]
VWATAVAWH
0A_A^A\_^
WATAUAVAWH
0A_A^A]A\_
d$0ffff
\$ UVWATAUAVAWH
|$<D8|$@t
A_A^A]A\_^]
USVWATAUAVAWH
A_A^A]A\_^[]
@UVWATH
l$ VATAVH
@SVWAVAWH
`A_A^_^[
fffffff
L$ SATAVAWH
HA_A^A\[
SUVATAUH
U fffff
A]A\^][
SUVWATAUAVAWH
A_A^A]A\_^][
UATAVAWH
(A_A^A\]
SUATAUAVAWH
A_A^A]A\][
@USVATAVH
A^A\^[]
USVWATAUAVAWH
T$pffffff
A_A^A]A\_^[]
\$D@8x	
UVWATAUAVAWH
A_A^A]A\_^]
D9b v.M
USVATAUAVAWH
veffffff
A_A^A]A\^[]
|$ ATAUAVH
t!D9r v
D9O v>E3
 A^A]A\
@USWATAUAVAWH
A_A^A]A\_[]
SAUAVAWH
8A_A^A][
UVWATAUAVAWH
H9q0t#H
 A_A^A]A\_^]
@USWATAVAWH
A_A^A\_[]
D$0ffff
D$0D;D$(
@SUWAUAVAWH
A_A^A]_][
A9x v\H
L$ UVWH
WATAUAVAWH
H;S8~eH
@A_A^A]A\_
WATAUAVAWH
0A_A^A]A\_
USVATAVAWH
pPwHt==
`Rw+t"=
fffffff
D9K v+A
A_A^A\^[]
USVATAUAVAWH
D$P;D$`s
A_A^A]A\^[]
SWATAVAWH
L$ ;L$$s
A_A^A\_[
@SUVATH
@UVAUAWH
XA_A]^]
@PwftzE
`hw"tDA
@Pwht|E
`hw"tDA
@!w1tR=
L$PH;A0
D$PH;H0
A8L9C8~
A8H9A0u>H
`bwbtZ=
paw!t1=
@gw+tR=
p`wQt"=
pcw+t?=
0fwQtC=
  w5td=
@!w5ti=
H9Y0t2H
SATAUAWH
A_A]A\[
L$ SVWAVAWH
pA_A^_^[
SUVWAWH
0A__^][
@0Ic@8I
H(M	X 3
$0< t.H
@SVWAUH
UVWATAUH
 A]A\_^]
@SUVWATH
l$ VWATH
H9D$@t*
UVWATAUH
 A]A\_^]
SUVATAWH
0A_A\^][
|$ ATAUAVH
 A^A]A\
@SUVWATH
 A\_^][
@SUVWATH
 A\_^][
WATAUAVAWH
 A_A^A]A\_
@8t$1t#H
t$,@8t$0t+H
ATAUAVH
pA^A]A\
t1fffffff
SUVWATAUAVAWH
8A_A^A]A\_^][
UVWATAUAVAWH
E0A9D$0
ExA9D$x
@A_A^A]A\_^]
;D$$u\H
@SAUAVAWL
A_A^A][
SUATAUH
G09A(u E
HA]A\][
@SUATAUAVH
A^A]A\][
UVWATAUAVAWH
I9k(umI
@A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
fffffff
E9G v'3
\$ VWATH
@UWATAVH
D$X+D$4
tSL9i(u.H
\$`L9j(usL
tjE9x<t\I
P!w8t]=
C0D;l$x
fffffff
C0A9E0w
T$P9t$Tt
Hc\$tLcD$pHcL$xL
fffffff
B@9C@uaL
L$@9J@u
	9G@u^H
ATAUAVH
fffffff
 A^A]A\
pPw_tW=
G09A0s!
\$@L96u
fffffff
|$ ATAUE3
A8pHt9M
E9H v$E3
D9} v$I
D9} vYM
E9B v\3
E9B v%3
E9a vaM
USWAVAWH
D9F v&3
A_A^_[]
SWATAUAVAWH
XA_A^A]A\_[
SWAVAWH
HA_A^_[
A9V v)I
t$ WATAUAVAWH
0A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
UATAUAVAWH
A_A^A]A\]
@USVATAUH
A]A\^[]
Ru0fffff
D9L$<u^L
UVWATAUAVAWH
pA_A^A]A\_^]
utD8fXunH
x}D9d$tu
d$<D8d$@t2H
d$tD8d$xt,H
@UVWAUAWH
A_A]_^]
\$ UVWH
WATAUAVAWH
@A_A^A]A\_
USVWATAUAVAWH
A_A^A]A\_^[]
|$ ATAUAVH
D9b v4A
 A^A]A\
VWATAUAVH
 A^A]A\_^
WATAUAVAWH
tPfffff
0A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
@VATAUH
ATAUAVAWH
(A_A^A]A\
ATAUAVAWH
HA_A^A]A\
@SWAUAVH
SVWATAWH
@A_A\_^[
|$\D8|$`t+H
@UWATAVAWH
 A_A^A\_]
L$\9L$D
@SUVATAWH
fffffff
teffffff
PA_A\^][
l$ WAUAVH
d$Pfffff
@SUVWATAUAVAWH
A_A^A]A\_^][
SUVWATAUAVAWH
L9q0t-H
8A_A^A]A\_^][
WATAUAVAWH
0A_A^A]A\_
@SATAUAVH
8A^A]A\[
USATAWH
@UVATAUAWH
A9|$ v1D
E9\$ vkE
A_A]A\^]
UWATAUAVAWH
t(fffff
A_A^A]A\_]
.|$Pz*u(
.|$Xz-u+@
USATAUI
@UVAUAVAWH
0A_A^A]^]
L9D$Xt3H
fffffff
T$`ffff
UXL9T$Xt7H
P A9D$x
@UATAVAWH
D$tHc\$t
A_A^A\]
Hz4u2fD
hz)u'Ic
Pz4u2fD
pz)u'Ic
Xz4u2fD
xz)u'Ic
@:t$HszA;
UVWATAUAVAWH
A_A^A]A\_^]
|$ ATAUAVAWE3
|$@A_A^A]A\
WATAUAVAWH
@A_A^A]A\_
L$ WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
@A_A^A]A\_
VWAUAVAWH
PA_A^A]_^
WATAUAVAWH
@A_A^A]A\_
WATAUAVAWH
@A_A^A]A\_
WATAUAVAWH
@A_A^A]A\_
WATAUAVAWH
@A_A^A]A\_
t$ WATAUAVAWH
\$(L9\$0u
@A_A^A]A\_
\$ L9\$(u)
D$`9D$hu
UVWATAUAVAWH
0A_A^A]A\_^]
D$ H9D$(ugHc
t$ WATAUAVAWH
D$(H9D$0u5
@A_A^A]A\_
t$ WATAUAVAWH
D$(H9D$0udHc
LcT$ A;
@A_A^A]A\_
t$ WATAUAVAWH
D$(H9D$0u5
@A_A^A]A\_
fffffff
|$ ATAUE
|$0A]A\
|$ ATAUAVAWA
|$@A_A^A]A\
UVWATAUAVAWH
fffffff
A_A^A]A\_^]
SUVWATAUAVAWH
fffffff
HA_A^A]A\_^][
|$ ATAUAVAWA
|$@A_A^A]A\
|$ ATAUAVAWA
|$@A_A^A]A\
|$ ATAUAVAWA
|$@A_A^A]A\
WATAUAVAWH
@A_A^A]A\_
|$ ATAUAVAW3
|$@A_A^A]A\
|$ ATAUAVAW3
|$@A_A^A]A\
UVWATAUAVAWD
\$HA_A^A]A\_^]
UVWATAUAVAWH
pA_A^A]A\_^]
p WATAUAVAWH
A_A^A]A\_
|$ ATAUAV3
|$8A^A]A\
|$ ATAUAV3
|$8A^A]A\
|$ ATAUAVAW3
|$@A_A^A]A\
|$ ATAUAV3
|$8A^A]A\
|$ ATAUAV3
|$8A^A]A\
H UVWATAUAVAWH
A_A^A]A\_^]
|$ ATAUAV3
|$8A^A]A\
|$ ATAUAV3
|$8A^A]A\
|$ ATAU3
|$0A]A\
|$ ATAU3
|$0A]A\
|$ ATAUAV3
|$8A^A]A\
|$ ATAUAV3
|$8A^A]A\
|$ ATAUAVAW3
|$@A_A^A]A\
|$ ATAUAVAW3
|$@A_A^A]A\
|$ ATAUAVAW3
|$@A_A^A]A\
|$ ATAUAVAW3
|$@A_A^A]A\
|$ ATAUAV3
|$8A^A]A\
UVWATAUAVAWH
0A_A^A]A\_^]
UVWATAUAVAWH
@A_A^A]A\_^]
.D$ z*u(I
ATAUAVAWH
(A_A^A]A\
UVWATAUAVAWH
`A_A^A]A\_^]
VWATAUAVH
A^A]A\_^
UVWATAUAVAWH
@A_A^A]A\_^]
WATAUAVAWH
 A_A^A]A\_
SUVWATAUAVAWH
XA_A^A]A\_^][
UVWATAUAVAWH
@A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
SUVWATAUAVAWH
\$PL9\$@u
D$(9D$ u
\$PL9\$@u
D$ 9D$(u
hA_A^A]A\_^][
UVATAUAVAWH
HA_A^A]A\^]
SUVWATAUAVAWH
XA_A^A]A\_^][
C09A0v6H
xK;|$Ls
t$L@8t$Pt2H
@XA9CXs
ATAUAVAWH
@XA9@Xs
t[ffffff
D9B v-E3
APD;B r
t=fffff
IXA9IXs
AXA9@Xv
hA_A^A]A\
|$ ATAUAVH
 A^A]A\
D$4LcD$0L
SUVWATAWH
A_A\_^][
D$Xfffffff
fffffff
\$ UVWATAWH
0A_A\_^]
L9y0t-H
0A_A\_^]
A9[ vML
A9[ vGH
@UATAUH
A9pPt*D
D9F v$3
SUVWATAUAVAWH
t5ffffff
8A_A^A]A\_^][
@SATAUAVH
(A^A]A\[
l$8fffff
WATAUAVAWH
0A_A^A]A\_
t E8hqt
SUVWATAUAWH
@A_A]A\_^][
ATAUAVAWH
8A_A^A]A\
D$Pffff
HxE8t$qtkH
;t$8v D8t$Au
D8u t0H
t$<D8t$@t+H
WATAUAVAWH
D9{ v+A
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
VWAUAVAWH
A_A^A]_^
UVWATAUAVAWH
E;uHrpE;uLwjH
0A_A^A]A\_^]
L$DA9N 
l$pfffff
|$pA;N 
D;D$Dsl
L9i0t-H
fD9o|tP
fD9o~tP
t$PA;\$
t$XA;|$
@SUVWAUH
UVWATAUAVAWH
E ffffff
t8fffff
`#w#t==
0A_A^A]A\_^]
UVWATAUAVAWH
`#w t:=
tBfffffff
`#w t:=
t"9r0t!H
`#w#tA=
@A_A^A]A\_^]
UVWATAUAVAWH
@0A9F0vlH
pA_A^A]A\_^]
fffffff
fD9n|tS
fD9n~tS
pPwct[=
;L$@sG;
WATAUAVAWH
@A_A^A]A\_
|$ ATAUL
t$fffff
|$0A]A\
l$(A]A\
@SUVWATAUAVAWH
D9{ vnI
A_A^A]A\_^][
PXL9I(H
D$0H90t{H
PXH9q(H
UUUUUUU
SUVWATAUAVAWH
 u(A9r<t"I
HA_A^A]A\_^][
@UATAWH
Affffff
T$XE;o0
A;GLvm;
A;GLrcD
A8A9C0u
`#w t:=
Q@fffffff
Spfffff
SUAVAWH
8A_A^][
~Pffffff
8A_A^][
UVWATAUAVAWH
`A_A^A]A\_^]
\$ UVWATAUAVAWH
F8t,Tt@H
A_A^A]A\_^]
d$0A9E0
pPw[tS=
L$@E9J 
L$@E;J 
D$pD;L$(
Qpfffff
t$HD9D$ uqL
SUVATAUAVAWH
PA_A^A]A\^][
t$ WATAUH
VWATAUAVAWH
A_A^A]A\_^
@SVWATH
@SUATAUAVH
A^A]A\][
D$(E;<$
D$0H9D$ 
UVWATAUAVAWH
A_A^A]A\_^]
VWATAUAWH
0A_A]A\_^
9kTv$ff
@SATAUH
@SUVWATAUAVH
0A^A]A\_^][
l$@t-fffff
t$ WAUAVH
u%D8e	u
\$ UVAUH
UVWAUAVH
A^A]_^]
L$ WATAUAVAWH
0A_A^A]A\_
tjffffff
tZfffff
tYHcC(;G(uP
tFfffffff
UVWATAUAVAWH
u*D93u%A
t	I;APt
A_A^A]A\_^]
fffffff
|$ ATAUAVH
 A^A]A\
UVWATAUAVAWH
A_A^A]A\_^]
@SUVATAU
A]A\^][
t$ WATAUH
t%<<u!L
@UATAUAVAWH
A_A^A]A\]
@SVWAUH
WATAUAVAWH
 A_A^A]A\_
@UATAUAVAWH
A_A^A]A\]
WATAUAVAWH
A_A^A]A\_
UVWATAUH
`A]A\_^]
\$0ffff
C@H9C0s
|$ UATAUAVAWH
A_A^A]A\]
 !"#$%&'()*+
,-.PPPPP///01
899::;;<=>?@ABBBCBBBBBDDEEEEEFEEEEPGGGGHHHHIJKLMNO
@USWATH
tDD8c"u>
uFD8c"u@
fffffff
+++++++++
++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++
 !"#$%&'()+++++++++++++++++++++++++++++++++++++++++++*f
@USVWATAUAVAWH
T$0Hc_X
D9|$pu_
D$09D$tuU
9D$|uWH
A_A^A]A\_^[]
D$tD; t
\$P;\$8
D$tD; t
\$P;\$8
D$tD; t
\$P;\$8
D$tD; t
\$P;\$8
D$@fffffff
t$H9D$P
t$HD;d$P
UATAUAVAWH
A_A^A]A\]
))))))))))
))))))))
)))))))))))))))))))) )!)")###$#####
%%%%%&%%%%)
AUAVAWH
\$0ffff
|$HH9(u&H
\$0ffff
|$HH9(u&H
WATAUAVAWH
H;s s	H
{@D8{Ht
{ D8{(t
{@D8{Ht
 A_A^A]A\_
k@D8kHt
k D8k(t
UVWATAUAVAWH
$2L;c8v
L;c@s	H
KPH;K@s
 A_A^A]A\_^]
VWATAUAVH
H;G@vhL
 A^A]A\_^
q@@8qHt
s @8s(t
x UATAUAVAWH
D9fTv-3
A_A^A]A\]
tMH!C@8CHt
o@D8oHt
o D8o(t
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
D$ ;D$(
@SUVWATAUAVAWH
HA_A^A]A\_^][
T$ ;T$0
ATAUAVH
 A^A]A\
x ATAUAVH
 A^A]A\
WATAUAVAWH
 A_A^A]A\_
UVWATAUAVAWH
@8l$ tuL
PA_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
UVWATAUAVAWH
t$8L!|$(I
`A_A^A]A\_^]
ATAUAVH
 A^A]A\
H3E H3E
__CxxFrameHandler
_vsnprintf
??3@YAXPEAX@Z
??2@YAPEAX_K@Z
tolower
isdigit
toupper
isalpha
memmove
_stricmp
isspace
strncmp
_purecall
_fpclass
_strnicmp
_controlfp
_clearfp
strrchr
_finite
isalnum
_mbstrlen
_strdup
setlocale
isxdigit
_strtoui64
_XcptFilter
_initterm
_amsg_exit
__C_specific_handler
msvcrt.dll
_CxxThrowException
??1type_info@@UEAA@XZ
?terminate@@YAXXZ
_unlock
__dllonexit
_onexit
DeleteObject
GDI32.dll
DisableThreadLibraryCalls
VirtualProtect
FreeLibrary
TlsAlloc
TlsSetValue
HeapDestroy
TlsGetValue
TlsFree
HeapAlloc
HeapFree
GetProcessHeap
lstrcmpiA
GetModuleHandleA
LoadLibraryA
GetProcAddress
OutputDebugStringA
HeapCreate
GetFullPathNameA
WideCharToMultiByte
MultiByteToWideChar
GetLastError
VirtualFree
VirtualAlloc
GetSystemInfo
InitializeCriticalSection
DeleteCriticalSection
UnmapViewOfFile
CloseHandle
RtlVirtualUnwind
RtlLookupFunctionEntry
RtlCaptureContext
QueryPerformanceCounter
GetTickCount
GetCurrentThreadId
GetCurrentProcessId
GetSystemTimeAsFileTime
TerminateProcess
GetCurrentProcess
UnhandledExceptionFilter
SetUnhandledExceptionFilter
KERNEL32.dll
D3DCOMPILER_43.dll
D3DAssemble
DebugSetMute
D3DCompile
D3DCompressShaders
D3DCreateBlob
D3DDecompressShaders
D3DDisassemble
D3DDisassemble10Effect
D3DGetBlobPart
D3DGetDebugInfo
D3DGetInputAndOutputSignatureBlob
D3DGetInputSignatureBlob
D3DGetOutputSignatureBlob
D3DPreprocess
D3DReflect
D3DReturnFailure1
D3DStripShader
"Copyright (c) 1997 Microsoft Corp.1
Microsoft Corporation1!0
Microsoft Root Authority0
070822223102Z
120825070000Z0y1
Washington1
Redmond1
Microsoft Corporation1#0!
Microsoft Code Signing PCA0
r0p1+0)
"Copyright (c) 1997 Microsoft Corp.1
Microsoft Corporation1!0
Microsoft Root Authority
Washington1
Redmond1
Microsoft Corporation1#0!
Microsoft Code Signing PCA0
091207224029Z
110307224029Z0
Washington1
Redmond1
Microsoft Corporation1
Microsoft Corporation0
3http://crl.microsoft.com/pki/crl/products/CSPCA.crl0H
,http://www.microsoft.com/pki/certs/CSPCA.crt0
"Copyright (c) 1997 Microsoft Corp.1
Microsoft Corporation1!0
Microsoft Root Authority0
060916010447Z
190915070000Z0y1
Washington1
Redmond1
Microsoft Corporation1#0!
Microsoft Timestamping PCA0
r0p1+0)
"Copyright (c) 1997 Microsoft Corp.1
Microsoft Corporation1!0
Microsoft Root Authority
Washington1
Redmond1
Microsoft Corporation1#0!
Microsoft Timestamping PCA0
080725190217Z
130725191217Z0
Washington1
Redmond1
Microsoft Corporation1
MOPR1'0%
nCipher DSE ESN:7A82-688A-9F921%0#
Microsoft Time-Stamp Service0
3http://crl.microsoft.com/pki/crl/products/tspca.crl0H
,http://www.microsoft.com/pki/certs/tspca.crt0
Washington1
Redmond1
Microsoft Corporation1#0!
Microsoft Code Signing PCA
 http://www.microsoft.com/directx0
Washington1
Redmond1
Microsoft Corporation1#0!
Microsoft Timestamping PCA
100522003051Z0#
